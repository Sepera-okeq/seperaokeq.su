
# Теория и Практика. Экзамен по АИАЯ

 Сделано sepera_okeq(Лешкевич Сергей).

# Содержание
<!-- TOC -->

- [Теория и Практика. Экзамен по АИАЯ](#%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F-%D0%B8-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0-%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD-%D0%BF%D0%BE-%D0%B0%D0%B8%D0%B0%D1%8F)
- [Содержание](#%D1%81%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5)
- [Синтаксические конструкции языка программирования С/С++](#%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D0%B8-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%81%D1%81)
    - [[~] Типы данных](#-%D1%82%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
        - [Символьные типы](#%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B)
        - [Целочисленные типы](#%D1%86%D0%B5%D0%BB%D0%BE%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B)
        - [Типы чисел с плавающей точкой](#%D1%82%D0%B8%D0%BF%D1%8B-%D1%87%D0%B8%D1%81%D0%B5%D0%BB-%D1%81-%D0%BF%D0%BB%D0%B0%D0%B2%D0%B0%D1%8E%D1%89%D0%B5%D0%B9-%D1%82%D0%BE%D1%87%D0%BA%D0%BE%D0%B9)
        - [Размеры типов данных](#%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%80%D1%8B-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
        - [Спецификатор auto](#%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80-auto)
    - [[~] Определение переменных](#-%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85)
        - [Инициализация по умолчанию](#%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE-%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E)
        - [Изменение значения](#%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F)
        - [Константы](#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D1%8B)
    - [[~] Операции и их использование в выражениях](#-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8-%D0%B8-%D0%B8%D1%85-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%D1%85)
        - [Арифметические операции](#%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8)
            - [+](#)
            - [-](#-)
            - [*](#)
            - [/](#)
            - [%](#%25)
            - [Префиксный инкремент](#%D0%BF%D1%80%D0%B5%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D1%8B%D0%B9-%D0%B8%D0%BD%D0%BA%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D1%82)
            - [Постфиксный инкремент](#%D0%BF%D0%BE%D1%81%D1%82%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D1%8B%D0%B9-%D0%B8%D0%BD%D0%BA%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D1%82)
            - [Префиксный декремент](#%D0%BF%D1%80%D0%B5%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D1%8B%D0%B9-%D0%B4%D0%B5%D0%BA%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D1%82)
            - [Постфиксный декремент](#%D0%BF%D0%BE%D1%81%D1%82%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D1%8B%D0%B9-%D0%B4%D0%B5%D0%BA%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D1%82)
        - [Битовые операторы](#%D0%B1%D0%B8%D1%82%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B)
            - [Операции сдвига](#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8-%D1%81%D0%B4%D0%B2%D0%B8%D0%B3%D0%B0)
                - [<<](#)
                - [>>](#)
            - [Поразрядные операции](#%D0%BF%D0%BE%D1%80%D0%B0%D0%B7%D1%80%D1%8F%D0%B4%D0%BD%D1%8B%D0%B5-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8)
    - [[~] Операторы](#-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B)
        - [Условный оператор](#%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B9-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80)
            - [Конструкция if](#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D1%8F-if)
            - [Конструкция switch](#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D1%8F-switch)
            - [Тернарный оператор](#%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B9-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80)
        - [Цикл с условием](#%D1%86%D0%B8%D0%BA%D0%BB-%D1%81-%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5%D0%BC)
            - [Цикл while](#%D1%86%D0%B8%D0%BA%D0%BB-while)
            - [Цикл for](#%D1%86%D0%B8%D0%BA%D0%BB-for)
            - [Цикл do](#%D1%86%D0%B8%D0%BA%D0%BB-do)
        - [Цикл с параметром](#%D1%86%D0%B8%D0%BA%D0%BB-%D1%81-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%BC)
        - [Операторы передачи управления break, continue, return](#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B8-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-break-continue-return)
            - [Операторы continue и break](#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-continue-%D0%B8-break)
            - [Оператор return](#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-return)
                - [Возвращение ссылки](#%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8)
    - [[~] Организация консольного ввода и вывода данных](#-%D0%BE%D1%80%D0%B3%D0%B0%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B2%D0%B2%D0%BE%D0%B4%D0%B0-%D0%B8-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
        - [Вывод на консоль](#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%BD%D0%B0-%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D1%8C)
        - [Ввод с консоли](#%D0%B2%D0%B2%D0%BE%D0%B4-%D1%81-%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D0%B8)
        - [Примеры ввода и вывода](#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D1%8B-%D0%B2%D0%B2%D0%BE%D0%B4%D0%B0-%D0%B8-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0)
            - [Ввод и вывод значения переменной](#%D0%B2%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%D0%B9)
            - [Ввод и вывод значений одномерного массива](#%D0%B2%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B9-%D0%BE%D0%B4%D0%BD%D0%BE%D0%BC%D0%B5%D1%80%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0)
            - [Ввод и вывод значений двумерные массива](#%D0%B2%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B4%D0%B2%D1%83%D0%BC%D0%B5%D1%80%D0%BD%D1%8B%D0%B5-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0)
            - [Ввод и вывод значений структуры](#%D0%B2%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B9-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B)

<!-- /TOC -->


# Синтаксические конструкции языка программирования С/С++

## [~] Типы данных

Каждая переменная имеет определенный тип. И этот тип определяет, какие значения может иметь переменная, какие операции с ней можно производить и сколько байт в памяти она будет занимать. В языке C++ определены следующие базовые типы данных:

**bool**: логический тип. Может принимать одну из двух значений true (истина) и false (ложь). Размер занимаемой памяти для этого типа точно не определен.

**char**: представляет один символ в кодировке ASCII. Занимает в памяти 1 байт (8 бит). Может хранить любое значение из диапазона от -128 до 127, либо от 0 до 255

**signed char**: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от -128 до 127

**unsigned char**: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от 0 до 255

**wchar_t**: представляет расширенный символ. На Windows занимает в памяти 2 байта (16 бит), на Linux - 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 65 535 (при 2 байтах), либо от 0 до 4 294 967 295 (для 4 байт)

**char16_t**: представляет один символ в кодировке Unicode. Занимает в памяти 2 байта (16 бит). Может хранить любой значение из диапазона от 0 до 65 535

**char32_t**: представляет один символ в кодировке Unicode. Занимает в памяти 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 4 294 967 295

**short**: представляет целое число в диапазоне от –32768 до 32767. Занимает в памяти 2 байта (16 бит).

Данный тип также имеет синонимы short int, signed short int, signed short.

**unsigned short**: представляет целое число в диапазоне от 0 до 65535. Занимает в памяти 2 байта (16 бит).

Данный тип также имеет синоним unsigned short int.

**int**: представляет целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита). Диапазон предельных значений соответственно также может варьироваться от –32768 до 32767 (при 2 байтах) или от −2 147 483 648 до 2 147 483 647 (при 4 байтах). Но в любом случае размер должен быть больше или равен размеру типа short и меньше или равен размеру типа long

Данный тип имеет синонимы signed int и signed.

**unsigned int**: представляет положительное целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита), и из-за этого диапазон предельных значений может меняться: от 0 до 65535 (для 2 байт), либо от 0 до 4 294 967 295 (для 4 байт).

В качестве синонима этого типа может использоваться unsigned

**long**: представляет целое число в диапазоне от −2 147 483 648 до 2 147 483 647. Занимает в памяти 4 байта (32 бита).

У данного типа также есть синонимы long int, signed long int и signed long

**unsigned long**: представляет целое число в диапазоне от 0 до 4 294 967 295. Занимает в памяти 4 байта (32 бита).

Имеет синоним unsigned long int.

**long long**: представляет целое число в диапазоне от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807. Занимает в памяти, как правило, 8 байт (64 бита).

Имеет синонимы long long int, signed long long int и signed long long.

**unsigned long long**: представляет целое число в диапазоне от 0 до 18 446 744 073 709 551 615. Занимает в памяти, как правило, 8 байт (64 бита).

Имеет синоним unsigned long long int.

**float**: представляет вещественное число ординарной точности с плавающей точкой в диапазоне +/- 3.4E-38 до 3.4E+38. В памяти занимает 4 байта (32 бита)

**double**: представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 1.7E-308 до 1.7E+308. В памяти занимает 8 байт (64 бита)

**long double**: представляет вещественное число двойной точности с плавающей точкой не менее 8 байт (64 бит). В зависимости от размера занимаемой памяти может отличаться диапазон допустимых значений.

**void**: тип без значения

Таким образом, все типы данных за исключением **void** могут быть разделены на три группы: **символьные** (char, wchar_t, char16_t, char32_t), **целочисленные** (short, int, long, long long) и **типы чисел с плавающей точкой** (float, double, long double).

### Символьные типы

Для представления символов в приложении используются типы *char, wchar_t, char16_t и char32_t*.

Определим несколько переменных:

```c++
char c ='d';
wchar_t d ='c';
```

Переменная типа *char* в качестве значения принимает один символ в одинарных кавычках: `char c ='d'`. Также можно присвоить число из указанного выше в списке диапазона: `char c = 120`. В этом случае значением переменной c будет тот символ, который имеет код 120 в таблице символов [ASCII](https://devdocs.io/cpp/language/ascii).

[Таблица ASCII](https://devdocs.io/cpp/language/ascii) (Только английские символы + спец символы.)

Стоит учитывать, что для вывода на консоль символов *wchar_t* следует использовать не `std::cout`, а поток `std::wcout`:

```c++
# include <iostream>

int main()
{
    char a = 'H';
    wchar_t b = 'e';
    std::wcout << a << b << '\n';
    return 0;
}
```

При этом поток `std::wcout` может работать как с *char*, так и с *wchar_t*. А поток `std::cout` для переменной *wchar_t* вместо символа будет выводить его числовой код.

В стандарте **С++11** были добавлены типы *char16_t* и *char32_t*, которые ориентированы на использование Unicode. Однако на уровне ОС пока не реализованы потоки для работы с этими типами. Поэтому если потребуется вывести на консоль значения переменных этих типов, то необходимо преобразовать переменные к типам *char* или *wchar_t*:

```c++
# include <iostream>

int main()
{
    char a = 'H';
    wchar_t b = 'e';
    char16_t c = 'l';
    char32_t d = 'o';
    std::cout << a << (char)b << (char)c << (char)d << "\n";
    return 0;
}
```

В данном случае при выводе перед переменными указывается операция приведения к типу *char* - `(char)`, благодаря чему значения переменных b, c и d преобразуются в тип *char* и могут быть выведены на консоль с помощью потока `std::cout`.

### Целочисленные типы

Целочисленные типы представлены следующими типами: *short, unsigned short, int, unsigned int, long, unsigned long, long long и unsigned long long*:

```c++
short a = -10;
unsigned short b = 10;
int c = -30;
unsigned int d = 60;
long e = -170;
unsigned long f = 45;
long long g = 89;
```

### Типы чисел с плавающей точкой

Типы чисел с плавающей точкой или дробные числа представлены такими типами как *float, double и long double*:

```c++
float a = -10.45;
double b = 0.00105;
long double c = 30.890045;
```

### Размеры типов данных

В выше приведенном списке для каждого типа указан размер, который он занимает в памяти. Однако стоит отметить, что предельные размеры для типов разработчики компиляторов могут выбирать самостоятельно, исходя из аппаратных возможностей компьютера. Стандарт устанавливает лишь минимальные значения, которые должны быть. Например, для типов *int* и *short* минимальное значение - 16 бит, для типа *long* - 32 бита, для типа *long double*. При этом размер типа *long* должен быть не меньше размера типа *int*, а размер типа *int* - не меньше размера типа *short*, а размер типа *long double* должен быть больше *double*. К примеру, компилятор g++ под Windows для *long double* использует 12 байт, а компилятор, встроенный в Visual Studio и также работающий под Windows, для *long double* использует 8 байт. То есть даже в рамках одной платформы разные компиляторы могут по разному подходить к размерам некоторых типов данных. Но в целом используются те размеры, которые указаны выше при описании типов данных.

Однако бывают ситуации, когда необходимо точно знать размер определенного типа. И для этого в С++ есть оператор `sizeof()`, который возвращает размер памяти в байтах, которую занимает переменная:

```c++
# include <iostream>

int main()
{
    long double number = 2;
    std::cout << "> sizeof(number) =" << sizeof(number);
    return 0;
}
```

Консольный вывод при компиляции в g++:

`> sizeof(number) = 12`

При этом при определении переменных важно понимать, что значение переменной не должно выходить за те пределы, которые очерчены для ее типа. Например:

`unsigned short number = -65535;`

Компиляция такого кода может пройти без ошибок, хотя некоторые компиляторы, как G++ могут выдавать предупреждения о том, что значение будет усечено. Однако при комиляции переменная number получит значение 1 - результат преобразования числа -65535 к типу *unsigned short*. То есть опять же результат будет не совсем тот, который ожидается. Значение переменной - это всего лишь набор битов в памяти, которые интерпретируются в соответствии с определенным типом. И для разных типов один и тот же набор битов может интерпретироваться по разному. Поэтому важно учитывать диапазоны значений для того или иного типа при присвоении переменной значения.

### Спецификатор auto

Иногда бывает трудно определить тип выражения. И согласно последним стандартам можно предоставить компилятору самому выводить тип объекта. И для этого применяется спецификатор auto. При этом если мы определяем переменную со спецификатором auto, эта переменная должна быть обязательно инициализирована каким-либо значением:

`auto number = 5;`
На основании присвоенного значения компилятор выведет тип переменной. Неинициализированные переменные со спецификатором auto не допускаются:

`auto number; // [Error] Ошибка! Нельзя использовать auto в неиницилизированных переменных.`

## [~] Определение переменных

Как и во многих языках программирования, в C++ для хранения данных используются переменные. Переменная имеет тип, имя и значение. Тип определяет, какую информацию может хранить переменная.

Перед использованием любую переменную надо определить. Синтаксис определения переменной выглядит следующим образом:

```c++
тип_переменной имя_переменной;
```

Простейшее определение переменной:

```c++
int age;
```

Здесь определена переменная age, которая имеет тип int. Поскольку определение переменной представляет собой инструкцию, то после него ставится точка с запятой.

Также стоит учитывать, что C++ - **регистрозависимый** язык, а это значит, что регистр символов имеет большое значение. То есть в следующем коде будут определяться две разные переменные:

```c++
int age;
int Age;
```

Поэтому переменная Age не будет представлять то же самое, что и переменная age.

Кроме того, в качестве имени переменной нельзя использовать ключевые слова языке C++, например, **for** или **if**. Но таких слов не так много: **alignas, alignof, asm, auto, bool, break, case, catch, char, char16_t, char32_t, class, const, constexpr, const_cast, continue, decltype, default, delete, do, double, dynamic_cast, else, enum, explicit, export, extern, false, float, for, friend, goto, if, inline, int, long, mutubale, namespace, new, noexcept, nullptr, operator, private, protected, public, register, reinterpret_cast, return, short, signed, sizeof, static, static_assert, static_cast, struct, switch, template, this, thread_local, throw, true, try, typedef, typeid, typename, union, unsigned, using, virtual, void, volatile, wchar_t, while**.

Также нельзя объявить больше одной переменной с одним и тем же именем, например:

```c++
int age;
int age;
```

Подобное определение вызовет ошибку на этапе компиляции.

И в довершеие следует сказать, что переменным стоит давать осмысленные имена, которые будут говорить об их предназначении.

Инициализация
После определения переменной можно присвоить некоторое значение:

```c++
int age;
age = 20;
```

Например, определим в прогамме переменную и выведем ее значение на консоль:

```c++
#include <iostream>
 
int main()
{
    int age;
    age = 28;
    std::cout<<"Age = " << age;
    return 0;
}
```

С помощью последовательности операторов `<<` можно вывести несколько значений на консоль.

После компиляции и запуска скомпилированной программы на консоль будет выведено число `28`.

Однако также можно сразу при определении переменной дать ей некоторое начальное значение. Данный прием называется инициализацией, то есть присвоение переменной начального значения:

```c++
#include <iostream>
 
int main()
{
    int age = 28;
    std::cout<<"Age = " << age;
    return 0;
}
```

### Инициализация по умолчанию

Если переменную не инициализировать, то происходит ее инициализация по умолчанию. И переменная получает некоторое значение по умолчанию, которое зависит от места, где эта переменная определена.

Если переменная, которая представляет встроенный тип (например, тип *int*), определена внутри функции, то она получает неопределенное значение. Если переменная встроенного типа определена вне функции, то она получает то значение по умолчанию, которое соответствует ее типу. Для числовых типов это число `0`. Например:

```c++
#include <iostream>
 
int x;
int main()
{
    int y;
    std::cout <<"X = " << x << "\n";
    std::cout <<"Y = " << y;
     
    return 0;
}
```

Переменная x определена вне функции, и поэтому она получит значение по умолчанию - число `0`.

Гораздо сложнее дело обстоит с переменной y, которая определена внутри функции main - ее значение будет неопределенным, и многое будет зависеть от используемого компилятора. В частности, вывод программы, скомпилированной с помощью компилятора G++, может выглядеть следующим образом:

```c
X = 0
Y = 4200475
```

А в Visual Studio отсутствие значения переменной y вызовет ошибку.

**Но в любом случае перед использованием переменной лучше явным образом назначать ей определенное значение, а не полагаться на значение по умолчанию.**

### Изменение значения

Ключевой особенностью переменных является то, что мы можем изменять их значения:

```c++
#include <iostream>
 
int main()
{
    int x = 6;
    x = 8;
    x = 10;
    std::cout <<"X = " << x; // X = 10
     
    return 0;
}
```

### Константы

Отличительной особенностью обычных переменных является то, что мы можем многократно в течение работы программы изменять их значение:

```c++
int x = 7;
x = 9;
x = 5;
```

Но кроме переменных в языке программирования C++ можно определять константы. Их значение устанавливается один раз и впоследствии мы его не можем изменить. Константа определяется практически также, как и переменная за тем исключением, что в начале определения константы идет ключевое слово *const*. Например:

```c++
const int x = 22;
std::cout << x;
```

Если же мы захотим после определения константы присвоить ей некоторое значение, то компилятор не сможет скомпилировать программу и выведет ошибку:

```c++
const int x = 22;
x = 78; // [Error] Ошибка! Идет присвоение значения к константной переменной!
```

То есть такой код не будет работать. И так как нельзя изменить значения константы, то ее всегда необходимо инициализировать, если мы хотим, чтобы она имела некоторое значение.

Если константа не будет инициализирована, то компилятор также выведет ошибку и не сможет скомпилировать программу, как в следующем случае:

```C++
const int x; // [Error] Ошибка! Переменная не иницилизирована!
```

В качестве значения константам можно передавать как обычные литералы, так и динамически вычысляемые значения, например, значения переменных или других констант:

```c++
int a = 10;
const int b = 7;
const int d = b;
const int x = a;
```

Обычно в качестве констант определяются такие значения, которые должны оставаться постоянными в течение работы всей программы и не могут быть изменены. Например, если программы выполняет математические операции с использованием числа **PI**, то было бы оптимально определить данные значение как константу, так как оно все равно в принципе неизменно:

```c++
const float pi = 3.14;
```

## [~] Операции и их использование в выражениях

### Арифметические операции

Арифметические операции производятся над числами. Значения, которые участвуют в операции, называются операндами. В языке программирования C++ арифметические операции **бинарными** (производятся над двумя операндами) и **унарными** (выполняются над одним операндом).

**К бинарным операциям относят следующие:**

#### `+`

Операция сложения возвращает сумму двух чисел:

```C++
int a = 10;
int b = 7;
int c = a + b;  // 17
int d = 4 + b;  // 11
```

#### `-`

Операция вычитания возвращает разность двух чисел:

```C++
int a = 10;
int b = 7;
int c = a - b;  // 3
int d = 41 - b; // 34
```

#### `*`

Операция умножения возвращает произведение двух чисел:

```C++
int a = 10;
int b = 7;
int c = a * b;  // 70
int d = b * 5;  // 35
```

#### `/`

Операция деления возвращает частное двух чисел:

```C++
int a = 20;
int b = 5;
int c = a / b;  // 4
double d = 22.5 / 4.5;  // 5
```

При делении стоит быть внимательным, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа, даже если результат присваивается переменной *float* или *double*:

```c++
double k = 10 / 4;     // 2
std::cout << k;
```

Чтобы результат представлял числос плавающей точкой, один из операндов также должен представлять число с плавающей точкой:

```c++
double k = 10.0 / 4;     // 2.5
std::cout << k;
```

#### `%`

Операция получения остатка от целочисленного деления:

```c++
int a = 33;
int b = 5;
int c = a % b;  // 3
int d = 22 % 4; // 2 (22 - 4*5 = 2)
```

Также есть **две унарные арифметические операции**, которые производятся над одним числом: *++* (инкремент) и *--* (декремент). Каждая из операций имеет две разновидности: префиксная и постфиксная:

#### Префиксный инкремент

Увеличивает значение переменной на единицу и полученный результат используется как значение выражения ++x

```c++
int a = 8;
int b = ++a;
std::cout << a << "\n"; // 9
std::cout << b << "\n"; // 9
```

#### Постфиксный инкремент

Увеличивает значение переменной на единицу, но значением выражения x++ будет то, которое было до увеличения на единицу

```c++
int a = 8;
int b = a++;
std::cout << a << "\n"; // 9
std::cout << b << "\n"; // 8
```

#### Префиксный декремент

Уменьшает значение переменной на единицу, и полученное значение используется как значение выражения --x

```c++
int a = 8;
int b = --a;
std::cout << a << "\n"; // 7
std::cout << b << "\n"; // 7
```

#### Постфиксный декремент

Уменьшает значение переменной на единицу, но значением выражения x-- будет то, которое было до уменьшения на единицу

```c++
int a = 8;
int b = a--;
std::cout << a << "\n"; // 7
std::cout << b << "\n"; // 8
```

Арифметические операции вычисляются слева направо. Одни операции имеют больший приоритет чем другие и поэтому выполняются вначале. Операции в порядке уменьшения приоритета:

```c
+ (инкремент), - (декремент)
* (умножение), / (деление), % (остаток от деления)
+ (сложение), - (вычитание)
```

Приоритет операций следует учитывать при выполнении набора арифметических выражений:

```c++
int a = 8;
int b = 7;
int c = a + 5 * ++b;      // 48
std::cout << c;
```

Хотя операции выполняются слева направо, но вначале будет выполняться операция инкремента `++b`, которая увеличит значение переменной *b* и возвратит его в качестве результата, так как эта операция имеет больший приоритет. Затем выполняется умножение `5 * ++b`, и только в последнюю очередь выполняется сложение `a + 5 * ++b`

Скобки позволяют переопределить порядок вычислений. Например:

```c++
int a = 8;
int b = 7;
int c = (a + 5) * ++b;      // 104
std::cout << c;
```

Несмотря на то, что операция сложения имеет меньший приоритет, но вначале будет выполняться именно сложение, а не умножение, так как операция сложения заключена в скобки.
___

### Битовые операторы

Побитовые операции выполняются над отдельными разрядами или битами чисел. Данные операции производятся только над целыми числами.

#### Операции сдвига

Каждое целое число в памяти представлено в виде определенного количества разрядов. И операции сдвига позволяют сдвинуть битовое представление числа на несколько разрядов вправо или влево. Операции сдвига применяются только к целочисленным операндам. Есть две операции:

##### `<<`

Сдвигает битовое представление числа, представленного первым операндом, влево на определенное количество разрядов, которое задается вторым операндом.

##### `>>`

Сдвигает битовое представление числа вправо на определенное количество разрядов.

Применение операций:

```C++
int a = 2 << 2;           // 10  на два разрядов влево = 1000 - 8
int b = 16 >> 3;          // 10000 на три разряда вправо = 10 - 2
```

Число 2 в двоичном представлении 10. Если сдвинуть число 10 на два разряда влево, то получится 1000, что в десятичной системе равно число 8.

Число 16 в двоичном представлении 10000. Если сдвинуть число 10 на три разряда вправо (три последних разряда отбрасываются), то получится 10, что в десятичной системе представляет число 2.

#### Поразрядные операции

Поразрядные операции также проводятся только над соответствующими разрядами целочисленных операндов:

**&**: поразрядная конъюнкция (операция И или поразрядное умножение). Возвращает 1, если оба из соответствующих разрядов обоих чисел равны 1

**|**: поразрядная дизъюнкция (операция ИЛИ или поразрядное сложение). Возвращает 1, если хотя бы один из соответствующих разрядов обоих чисел равен 1

**^**: поразрядное исключающее ИЛИ. Возвращает 1, если только один из соответствующих разрядов обоих чисел равен 1

**~**: поразрядное отрицание или инверсия. Инвертирует все разряды операнда. Если разряд равен 1, то он становится равен 0, а если он равен 0, то он получает значение 1.

Применение операций:

```C++
int a = 5 | 2;          // 101 | 010 = 111  - 7
int b = 6 & 2;          // 110 & 010 = 10  - 2
int c = 5 ^ 2;          // 101 ^ 010 = 111 - 7
int d = ~9;             // -10
```

Например, выражение 5 | 2 равно 7. Число 5 в двоичной записи равно 101, а число 2 - 10 или 010. Сложим соответствующие разряды обоих чисел. При сложении если хотя бы один разряд равен 1, то сумма обоих разрядов равна 1. Поэтому получаем:

```c
1 0 1
0 1 0
1 1 1
```

В итоге получаем число 111, что в десятичной записи представляет число 7.

Возьмем другое выражение `6 & 2`. Число *6* в двоичной записи равно *110*, а число *2* - *10* или *010*. Умножим соответствующие разряды обоих чисел. Произведение обоих разрядов равно *1*, если оба этих разряда равны *1*. Иначе произведение равно *0*. Поэтому получаем:

```C
1 1 0
0 1 0
0 1 0
```

Получаем число *010*, что в десятичной системе равно *2*.

## [~] Операторы

### Условный оператор

Условные конструкции направляют ход программы по одному из возможных путей в зависимости от условия.

#### Конструкция if

Конструкция if проверяет истинность условия, и если оно истинно, выполняет блок инструкций. Этот оператор имеет следующую сокращенную форму:

```c++
if (условие)
{
    инструкции;
}
```

В качестве условия использоваться условное выражение, которое возвращает *true* или *false*. Если условие возвращает *true*, то выполняются последующие инструкции, которые входят в блок `if`. Если условие возвращает *false*, то последующие инструкции не выполняются. Блок инструкций заключается в фигурные скобки.

Например:

```c++
#include <iostream>
 
int main()
{
    int x = 60;
      
    if(x > 50)
    {
        std::cout << "x is greater than 50 \n";
    }
      
    if(x < 30)
    {
        std::cout << "x is less than 30 \n";
    }
     
    std::cout << "End of Program" << "\n";
    return 0;
}
```

Здесь определены две условных конструкции `if`. Они проверят больше или меньше значение переменной *x*, чем определенное значение. В качестве инструкции в обоих случаях выполняется вывод некоторой строки на консоль.

В первом случае `x > 50` условие истинно, так как значение переменной *x* действительно больше `50`, поэтому это условие возвратит *true*, и, следовательно, будут выполнятся инструкции, которые входят в блок `if`.

Во втором случае операция отношения `x < 30` возвратит *false*, так как условие ложно, поэтому последующий блок инструкций выполняться не будет. В итоге при запуске программы вывод консоли будет выглядеть следующим образом:

```c
x greater than 50
End of Program
```

Также мы можем использовать полную форму конструкции `if`, которая включает оператор `else`:

```c++
if(выражение_условия)
    инструкция_1
else
    инструкция_2
```

После оператора `else` мы можем определить набор инструкций, которые выполняются, если условие в операторе `if` возвращает *false*. То есть если условие истинно, выполняются инструкции после оператора `if`, а если это выражение ложно, то выполняются инструкции после оператора `else`.

```c++
int x = 50;
if(x > 60) 
    std::cout << "x is greater than 60 \n";
else
    std::cout << "x is less or equal 60 \n";
```

В данном случае условие `x > 60` ложно, то есть возвращает *false*, поэтому будет выполняться блок `else`. И в итоге на консоль будет выведена строка `"x is less or equal 60 \n"`.

Однако нередко надо обработать не два возможных альтернативных варианта, а гораздо больше. Например, в случае выше можно насчитать три условия: переменная *x* может быть больше `60`, меньше `60` и равна `60`. Для проверки альтернативных условий мы можем вводить выражения `else if`:

```C++
int x = 60;
     
if(x > 60)
{
    std::cout << "x is greater than 60 \n";
}
else if (x < 60)
{
    std::cout << "x is less than 60 \n";
}
else
{
    std::cout << "x is equal 60 \n";
}
```

То есть в данном случае мы получаем три ветки развития событий в программе.

Если в блоке `if` или `else` или `else-if` необходимо выполнить только одну инструкцию, то фигурные скобки можно опустить:

```c++
int x = 60;
     
if(x > 60)
    std::cout << "x is greater than 60 \n";
else if (x < 60)
    std::cout << "x is less than 60 \n";
else
    std::cout << "x is equal 60 \n";
    
```

#### Конструкция switch

Другую форму организации ветвления программ представляет конструкция `switch...case`. Она имеет следующую форму:

```c++
switch(выражение)
{
    case константа_1: инструкции_1;
    case константа_2: инструкции_2;
     
    default: инструкции;
}
```

После ключевого слова `switch` в скобках идет сравниваемое выражение. Значение этого выражения последовательно сравнивается со значениями после оператора `сase`. И если совпадение будет найдено, то будет выполняться определенный блок `сase`.

В конце конструкции `switch` может стоять блок `default`. Он необязателен и выполняется в том случае, если значение после `switch` не соответствует ни одному из операторов `case`. Например:

```C++
#include <iostream>
 
int main()
{
    int x = 2;
      
    switch(x)
    {
        case 1: 
            std::cout << "x = 1" << "\n";
            break;
        case 2: 
            std::cout << "x = 2" << "\n";
            break;
        case 3: 
            std::cout << "x = 3" << "\n";
            break;
        default: 
            std::cout << "x is undefined" << "\n";
            break;
    }
    return 0;
}
```

Чтобы избежать выполнения последующих блоков `case/default`, в конце каждого блока ставится оператор `break`. То есть в данном случае будет выполняться оператор

```C++
case 2: 
    std::cout << "x = 2" << "\n";
    break;
```

После выполнения оператора `break` произойдет выход из конструкции `switch..case`, и остальные операторы `case` будут проигнорированы. Поэтому на консоль будет выведена следующая строка:
```x = 2```

Стоит отметить важность использования оператора `break`. Если мы его не укажем в блоке `case`, то после этого блока выполнение перейдет к следующему блоку `case`. Например, уберем из предыдущего примера все операторы `break`:

```c++
#include <iostream>
 
int main()
{
    int x = 2;
      
    switch(x)
    {
        case 1: 
            std::cout << "x = 1" << "\n";
        case 2: 
            std::cout << "x = 2" << "\n";
        case 3: 
            std::cout << "x = 3" << "\n";
        default: 
            std::cout << "x is undefined" << "\n";
    }
    return 0;
}
```

В этом случае опять же будет выполняться оператор `case 2:`, так как переменная `x=2`. Однако так как этот блок `case` не завершается оператором `break`, то после его завершения будет выполняться набор инструкций после `case 3`: даже несмотря на то, что переменная *x* по прежнему равна `2`. В итоге мы получим следующий консольный вывод:

```c
x = 2
x = 3
x is undefined
```

#### Тернарный оператор

Тернарный оператор `?:` позволяет сократить определение простейших условных конструкций if и имеет следующую форму:

`[первый операнд - условие] ? [второй операнд] : [третий операнд]`

Оператор использует сразу три операнда. В зависимости от условия тернарный оператор возвращает второй или третий операнд: если условие равно *true* (то есть истинно), то возвращается второй операнд; если условие равно *false* (то есть ложно), то третий. Например:

```c++
#include <iostream>
 
int main()
{
    setlocale(LC_ALL, "");
    int x = 5; 
    int y = 3;
    char sign;
    std::cout << "Введите знак операции: ";
    std::cin >> sign;
    int result = sign=='+'?x + y:x - y;
    std::cout << "Результат: " << result << "\n";
    return 0;
}
```

В данном случае производится ввод знака операции. Здесь результатом тернарной операции является переменная `result`. И если переменная sign содержит знак "+", то `result` будет равно второму операнду - `(x+y)`. Иначе `result` будет равно третьему операнду.

Чтобы понять как точно работает тернарный оператор, имеется пример с использованием конструкции `if`:

```c++
int main()
{
    bool a = true;
    int b;
    if(a) // Аналогично (a == true)
    {
        b = 1;
    }
    else
    {
        b = 2;
    }
    cout << b; 
}
```

Вывод в консоли:
`1`

Перепишем с использованием тернатного оператора:

```c++
int main()
{
    bool a = true;
    int b;
    b = a ? 1 : 2;
    cout << b; 
}
```

Вывод в консоли:
`1`

### Цикл с условием

Для выполнения некоторых действий множество раз в зависимости от определенного условия используются циклы. В языке C++ имеются следующие виды циклов:

- `for`
- `while`
- `do...while`

#### Цикл while

Цикл while выполняет некоторый код, пока его условие истинно, то есть возвращает true. Он имеет следующее формальное определение:

```c++
while(условие)
{
    // выполняемые действия
}
```

После ключевого слова `while` в скобках идет условное выражение, которое возвращает *true* или *false*. Затем в фигурных скобках идет набор инструкций, которые составляют тело цикла. И пока условие возвращает *true*, будут выполняться инструкции в теле цикла.

Например, выведем квадраты чисел от 1 до 9:

```c++
#include <iostream>
 
int main()
{   
    int i = 1;
    while(i < 10)
    {
        std::cout << i << " * " << i << " = " << i * i << std::endl;
        i++;
    }
     
    return 0;
}
```

Здесь пока условие `i < 10` истинно, будет выполняться цикл `while`, в котором выводится на консоль квадрат числа и инкрементируется переменная *i*. В какой-то момент переменная *i* увеличится до `10`, условие `i < 10` возвратит *false*, и цикл завершится.

Консольный вывод программы:

```c
1 * 1 = 1
2 * 2 = 4
3 * 3 = 9
4 * 4 = 16
5 * 5 = 25
6 * 6 = 36
7 * 7 = 49
8 * 8 = 64
9 * 9 = 81
```

Каждый отдельный проход цикла называется итерацией. То есть в примере выше было 9 итераций.

Если цикл содержит одну инструкцию, то фигурные скобки можно опустить:

```c++
int i = 0;
while(++i < 10)
    std::cout << i << " * " << i << " = " << i * i << std::endl;
```

#### Цикл for

Цикл for имеет следующее формальное определение:

```c++
for (выражение_1; выражение_2; выражение_3)
{
    // тело цикла
}
```

**выражение_1** выполняется один раз при начале выполнения цикла и представляет установку начальных условий, как правило, это инициализация счетчиков - специальных переменных, которые используются для контроля за циклом.

**выражение_2** представляет условие, при соблюдении которого выполняется цикл. Как правило, в качестве условия используется операция сравнения, и если она возвращает ненулевое значение (то есть условие истинно), то выполняется тело цикла, а затем вычисляется выражение_3.

**выражение_3** задает изменение параметров цикла, нередко здесь происходит увеличение счетчиков цикла на единицу.

Например, перепишем программу по выводу квадратов чисел с помощью цикла `for`:

```c++
#include <iostream>
 
int main()
{   
    for(int i = 1; i < 10; i++)
    {
        std::cout << i << " * " << i << " = " << i * i << std::endl;
    }
     
    return 0;
}
```

Первая часть объявления цикла - `int i = 1` - создает и инициализирует счетчик *i*. Фактически это то же самое, что и объявление и инициализация переменной. Счетчик необязательно должен представлять тип `int`. Это может быть и другой числовой тип, например, `float`. И перед выполнением цикла его значение будет равно `1`.

Вторая часть - условие, при котором будет выполняться цикл. В данном случае цикл будет выполняться, пока переменная `i` не станет равна `10`.

И третья часть - приращение счетчика на единицу. Опять же нам необязательно увеличивать на единицу. Можно уменьшать: `i--`. Можно изменять на другое значение: `i+=2`.

В итоге блок цикла сработает `9` раз, пока переменная *i* не станет равна `10`. И каждый раз это значение будет увеличиваться на `1`. И по сути мы получим тот же самый результат, что и в случае с циклом `while`:

```c++
1 * 1 = 1
2 * 2 = 4
3 * 3 = 9
4 * 4 = 16
5 * 5 = 25
6 * 6 = 36
7 * 7 = 49
8 * 8 = 64
9 * 9 = 81
```

Необязательно указывать все три выражения в определении цикла, мы можем одно или даже все из них опустить:

```C++
int i = 1;
for(; i < 10;)
{
    std::cout << i << " * " << i << " = " << i * i << std::endl;
    i++;
}
```

Формально определение цикла осталось тем же, только теперь первое и третье выражения в определении цикла отсутствуют: `for (; i < 10;)`. 

Переменная-счетчик определена и инициализирована вне цикла, а ее приращение происходит в самом цикле.

Можно определять вложенные циклы. Например, выведем таблицу умножения:

```C++
#include <iostream>
 
int main()
{   
    for (int i=1; i < 10; i++)
    {
        for(int j = 1; j < 10; j++)
        {
            std::cout << i * j << "\t";
        }
        std::cout << std::endl;
    }
     
    return 0;
}
```

Таблица умножения на языке C++ в консоли:

![image](https://metanit.com/cpp/tutorial/pics/2.1.png)

#### Цикл do

В цикле `do` сначала выполняется код цикла, а потом происходит проверка условия в инструкции `while`. И пока это условие истинно, то есть не равно `0`, то цикл повторяется. Формальное определение цикла:

```C++
do
{
    инструкции
}
while(условие);
```

Например:

```C++
#include <iostream>
 
int main()
{   
    int i = 6;
    do
    {
        std::cout << i << std::endl;
        i--;
    }
    while(i > 0);
     
    return 0;
}
```

Здесь код цикла сработает 6 раз, пока *i* не станет равным нулю.

Но важно отметить, что цикл do гарантирует хотя бы однократное выполнение действий, даже если условие в инструкции `while` не будет истинно. То есть мы можем написать:

```c++
int i = -1;
do
{
    std::cout << i << std::endl;
    i--;
}
while(i > 0);
```

Хотя у нас переменная *i* меньше 0, цикл все равно один раз выполнится.

### Цикл с параметром

С.м цикл `for`.

Особенность данного цикла является то, что (другое его название - цикл по переменной) позволяет выполнить набор команд фиксированное число раз, т.е. число итераций должно быть известно до начала выполнения цикла. Особенностью данного цикла является то, что заводится специальная переменная-счётчик, которая последовательно проходит указанный диапазон значений.

### Операторы передачи управления (break, continue, return)

#### Операторы continue и break

Иногда возникает необходимость выйти из цикла до его завершения. В этом случае можно воспользоваться оператором `break`. Например:

```c++
#include <iostream>
 
int main()
{
    int i = 1;
    for ( ; ; )
    {
        std::cout << i << " * " << i << " = " << i * i << std::endl;
        i++;
        if (i > 9) break;
    }
    return 0;
}
```

Здесь когда значение переменной `i` достигнет `10`, осуществляется выход из цикла с помощью оператора `break`.

В отличие от оператора `break`, оператор `continue` производит переход к следующей итерации. Например, нам надо посчитать сумму только нечетных чисел из некоторого диапазона:

```c++
#include <iostream>
int main()
{
    int result = 0;
    for (int i=0; i<10; i++)
    {
        if (i % 2 == 0) continue;
        result +=i;
    }
    std::cout << "result = " << result << std::endl; // 25
    return 0;
}
```

Чтобы узнать, четное ли число, мы получаем остаток от целочисленного деления на 2, и если он равен 0, то с помощью оператора `continue` переходим к следующей итерации цикла. А если число нечетное, то складываем его с остальными нечетными числами.

#### Оператор return

Для возвращения результата из функции применяется оператор return. Этот оператор имеет две формы:

```c
return;
return выражение;
```

Первая форма используется, если в качестве возвращаемого типа функции применяется тип `void`. Например:

```c++
#include <iostream>
 
void factorial(int);
 
int main()
{
    factorial(-3);
    factorial(5);
    factorial(4);
    return 0;
}
 
void factorial(int n)
{
    if(n<1)
    {
        std::cout << "Incorrect number" << std::endl;
        return;
    }
    int result = 1;
    for(int i = 1; i <=n; i++)
    {
        result *= i;
    }
    std::cout << "Factorial of " << n << " is equal to " << result << std::endl;
}
```

В данном случае функция `factorial` вычисляет факториал переданного числа. Однако если число меньше `1`, то функция выводит соответствующее сообщение, и с помощью оператора return осуществляется выход из функции.

Вторая форма оператора `return` применяется для возвращения результата из функции. Если функция имеет в качестве возвращаемого типа любой тип, отличный от `void`, то такая функция обязятельно должна возвратить некоторое значение с помощью оператора `return`. Причем значение, которое возвращается оператором `return`, должно соответствовать возвращаемому типу функции, либо допускать неявное преобразование в этот тип.

Например, возвратим из функции факториал числа:

```c++
#include <iostream>
 
int factorial(int);
 
int main()
{
    int n = 5;
    int result = factorial(n);
    std::cout << "Factorial of " << n << " is equal to " << result << std::endl;
    return 0;
}

int factorial(int n)
{
    int result = 1;
    for(int i = 1; i <=n; i++)
    {
        result *= i;
    }
    return result;
}
```

Так как функция `factorial` возвращает значение, то ее результат можно присвоить какой-нибудь переменной или константе:

```int result = factorial(n);```

##### Возвращение ссылки

Не следует возвращать ссылку на локальный объект, который создается внутри функции. Поскольку все создаваемые в функции объекты удаляются после ее завершения, а их память очищается, то возвращаемая ссыла будет указывать на несуществующий объект, как в следующем случае:

```c++
int& factorial(int n)
{
    int result = 1;
    for(int i = 1; i <=n; i++)
    {
        result *= i;
    }
    return result;
}
```

## [~] Организация консольного ввода и вывода данных

По умолчанию язык C++ не содержит встроенных средств для ввода с консоли и вывода на консоль, эти средства предоставляются библиотекой `iostream`. В ней определены два типа: `istream` и `ostream`. `istream` представляет поток ввода, а `ostream` - поток вывода.

Вобще сам темин "поток" в данном случае представляет последовательность символов, которая записывается на устройство ввода-вывода или считывается с него. И в данном случае под устройством ввода-вывода рассматривается консоль.

Для записи или вывода символов на консоль применяется объект `cout`, который представляет тип `ostream`. А для чтения с консоли используется объект `cin`

Для использования этих объектов в начало исходного файла необходимо подключить библиотеку `iostream`:

```c++
#include <iostream>
```

### Вывод на консоль

Для вывода на консоль применяется оператор `<<`. Этот оператор получает два операнда. Левый операнд представляет объект типа `ostream`, в данном случае объект `cout`. А правый операнд - значение, которое надо вывести на консоль.

Так как оператор `<<` возвращает левый операнд - `cout`, то с помощью цепочки операторов мы можем передать на консоль несколько значений. Например, определим простейшую программу вывода на консоль:

```c++
#include <iostream>
 
int main()
{   
    int age = 33;
    double weight = 81.23;
    std::cout << "Name: " << "Tom" << "\n";
    std::cout << "Age: " << age << std::endl;
    std::cout << "Weight: " << weight << std::endl;
    return 0;
}
```

Консольный вывод программы:

```c
Name: Tom
Age: 33
Weight: 81.23
```

Оператору `<<` передаются различные значения - строки, значения переменных, которые выводятся на консоль.

Строки могут содержать управляющие последовательности, которые интерпретируются определенным образом. Например, последовательность `"\n"` интерпретируется как перевод на новую строку. Из других управляющих последовательностей также нередко употребляется `"\t"`, которая интерпретируется как табуляция.

Также цепочку операторов << можно завершать значением `std::endl`, которое вызывает перевод на новую строку и сброс буфера. При выводе в поток данные вначале помещаются в буфер. И сброс буфера гарантирует, что все переданные для вывода на консоль данные немедлено будут выведены на консоль.

### Ввод с консоли

Для считывания с консоли данных применяется оператор ввода `>>,` который принимает два операнда. Левый операнд представляет объект типа `istream` (в данном случае объект `cin`), с которого производится считывание, а правый операнд - объект, в который считываются данные.

Например, считаем данные с консоли:

```c++
#include <iostream>
 
int main()
{   
    int age;
    double weight;
    std::cout << "Input age: ";
    std::cin >> age;
    std::cout << "Input weight: ";
    std::cin >> weight;
    std::cout << "Your age: " << age << "\t your weight: " << weight << std::endl;
    return 0;
}
```

Здесь после приглашений к вводу программа ожидает ввода значений для переменных `age` и `weight`.

Пример работы программы:

```c
Input age: 32
Input weight: 67.45
Your age: 32 your weight: 67.45
```

Стоит отметить, что так оператор ввода в первом случае будет добавлять данные в целочисленную переменную `age`, то он ожидает ввода числа. В случае с переменной `weight` оператор ввода ожидает дробное число, причем разделителем целой и дробной части должна быть точка. Поэтому мы не можем ввести любые значения, например, строки. В этом случае программа может выдать некорректный результат.

Оператор ввода >> возвращает левый операнд - объект `cin`, поэтому мы можем по цепочке считывать данные в различные переменные:

```c++
#include <iostream>
 
int main()
{   
    int age;
    double weight;
    std::cout << "Input age: ";
    std::cin >> age >> weight;
    std::cout << "Your age: " << age << "\t your weight: " << weight << std::endl;
    return 0;
}
```

```c
Пример работы программы:

Input age: 32 67.45
Your age: 32 your weight: 67.45
```

После ввода одного из значений надо будет ввести пробел и затем вводить следующее значение.

### Примеры ввода и вывода

#### Ввод и вывод значения переменной

```c++
#include <iostream>
 
int main()
{ 
    int a;
    cin >> a;
    cout << a;
}
```

#### Ввод и вывод значений одномерного массива

```c++
#include <iostream>
 
int main()
{ 
    int a[10];
    
    /* Ввод в массив из консоли*/
    for(int i = 0; i < 10; i++)
        cin >> a[i];

    /* Вывод массива в консоль*/
    for(int i = 0; i < 10; i++)
        cout << a[i];
}
```

#### Ввод и вывод значений двумерные массива

```c++
#include <iostream>
 
int main()
{ 
    int a[10][3];
    
    /* Ввод в массив из консоли*/
    for(int i = 0; i < 10; i++)
        for(int j = 0; j < 3; j++)
            cin >> a[i][j];

    /* Вывод массива в консоль*/
    for(int i = 0; i < 10; i++)
        for(int j = 0; j < 3; j++)
            cout << a[i][j];
}
```

#### Ввод и вывод значений структуры

```c++
#include <iostream>

struct date {
    string text;
    int month;
    int year;
};

void main() 
{
    date object;
    cin >> object2.text >> object2.month >> object2.year; // Ввод значений структуры в одну строку.
    cout << object2.text << object2.month << object2.year; // Вывод значений структуры в одну строку.
}
```
