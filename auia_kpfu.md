
# Теория и Практика. Экзамен по АИАЯ

Все вопросы и предложения направлять сюда: <https://vk.com/sepera_okeq>

Сделано sepera_okeq(Лешкевич Сергей).

# Содержание
<!-- TOC -->

- [Теория и Практика. Экзамен по АИАЯ](#%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F-%D0%B8-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0-%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD-%D0%BF%D0%BE-%D0%B0%D0%B8%D0%B0%D1%8F)
- [Содержание](#%D1%81%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5)
- [Не относящее к теме экзамена](#%D0%BD%D0%B5-%D0%BE%D1%82%D0%BD%D0%BE%D1%81%D1%8F%D1%89%D0%B5%D0%B5-%D0%BA-%D1%82%D0%B5%D0%BC%D0%B5-%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD%D0%B0)
    - [[~] Что же такое ваш этот C++?](#-%D1%87%D1%82%D0%BE-%D0%B6%D0%B5-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B2%D0%B0%D1%88-%D1%8D%D1%82%D0%BE%D1%82-c)
        - [Описание языка C++ и его история](#%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0-c-%D0%B8-%D0%B5%D0%B3%D0%BE-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F)
        - [Основные этапы развития С++](#%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D1%8D%D1%82%D0%B0%D0%BF%D1%8B-%D1%80%D0%B0%D0%B7%D0%B2%D0%B8%D1%82%D0%B8%D1%8F-%D1%81)
        - [Компиляторы и среды разработки](#%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D1%8B-%D0%B8-%D1%81%D1%80%D0%B5%D0%B4%D1%8B-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8)
    - [[~] Локализация и кириллица в консоли](#-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%B8-%D0%BA%D0%B8%D1%80%D0%B8%D0%BB%D0%BB%D0%B8%D1%86%D0%B0-%D0%B2-%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D0%B8)
    - [[~] Пространства имен и using](#-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%B0-%D0%B8%D0%BC%D0%B5%D0%BD-%D0%B8-using)
- [Синтаксические конструкции языка программирования С/С++](#%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D0%B8-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%81%D1%81)
    - [[~] Типы данных](#-%D1%82%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
        - [Символьные типы](#%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B)
        - [Целочисленные типы](#%D1%86%D0%B5%D0%BB%D0%BE%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B)
        - [Типы чисел с плавающей точкой](#%D1%82%D0%B8%D0%BF%D1%8B-%D1%87%D0%B8%D1%81%D0%B5%D0%BB-%D1%81-%D0%BF%D0%BB%D0%B0%D0%B2%D0%B0%D1%8E%D1%89%D0%B5%D0%B9-%D1%82%D0%BE%D1%87%D0%BA%D0%BE%D0%B9)
        - [Размеры типов данных](#%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%80%D1%8B-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
        - [Спецификатор auto](#%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80-auto)
    - [[~] Определение переменных](#-%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85)
        - [Инициализация по умолчанию](#%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE-%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E)
        - [Изменение значения](#%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F)
        - [Константы](#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D1%8B)
    - [[~] Операции и их использование в выражениях](#-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8-%D0%B8-%D0%B8%D1%85-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%D1%85)
        - [Арифметические операции](#%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8)
            - [+](#)
            - [-](#-)
            - [*](#)
            - [/](#)
            - [%](#%25)
            - [Префиксный инкремент](#%D0%BF%D1%80%D0%B5%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D1%8B%D0%B9-%D0%B8%D0%BD%D0%BA%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D1%82)
            - [Постфиксный инкремент](#%D0%BF%D0%BE%D1%81%D1%82%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D1%8B%D0%B9-%D0%B8%D0%BD%D0%BA%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D1%82)
            - [Префиксный декремент](#%D0%BF%D1%80%D0%B5%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D1%8B%D0%B9-%D0%B4%D0%B5%D0%BA%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D1%82)
            - [Постфиксный декремент](#%D0%BF%D0%BE%D1%81%D1%82%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D1%8B%D0%B9-%D0%B4%D0%B5%D0%BA%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D1%82)
        - [Битовые операторы](#%D0%B1%D0%B8%D1%82%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B)
            - [Операции сдвига](#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8-%D1%81%D0%B4%D0%B2%D0%B8%D0%B3%D0%B0)
                - [<<](#)
                - [>>](#)
            - [Поразрядные операции](#%D0%BF%D0%BE%D1%80%D0%B0%D0%B7%D1%80%D1%8F%D0%B4%D0%BD%D1%8B%D0%B5-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8)
    - [[~] Операторы](#-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B)
        - [Условный оператор](#%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B9-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80)
            - [Конструкция if](#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D1%8F-if)
            - [Конструкция switch](#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D1%8F-switch)
            - [Тернарный оператор](#%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B9-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80)
        - [Цикл с условием](#%D1%86%D0%B8%D0%BA%D0%BB-%D1%81-%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5%D0%BC)
            - [Цикл while](#%D1%86%D0%B8%D0%BA%D0%BB-while)
            - [Цикл for](#%D1%86%D0%B8%D0%BA%D0%BB-for)
            - [Цикл do](#%D1%86%D0%B8%D0%BA%D0%BB-do)
        - [Цикл с параметром](#%D1%86%D0%B8%D0%BA%D0%BB-%D1%81-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%BC)
        - [Операторы передачи управления break, continue, return](#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B8-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-break-continue-return)
            - [Операторы continue и break](#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-continue-%D0%B8-break)
            - [Оператор return](#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-return)
                - [Возвращение ссылки](#%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8)
    - [[~] Организация консольного ввода и вывода данных](#-%D0%BE%D1%80%D0%B3%D0%B0%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B2%D0%B2%D0%BE%D0%B4%D0%B0-%D0%B8-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
        - [Вывод на консоль](#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%BD%D0%B0-%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D1%8C)
        - [Ввод с консоли](#%D0%B2%D0%B2%D0%BE%D0%B4-%D1%81-%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D0%B8)
        - [Примеры ввода и вывода](#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D1%8B-%D0%B2%D0%B2%D0%BE%D0%B4%D0%B0-%D0%B8-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0)
            - [Ввод и вывод значения переменной](#%D0%B2%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%D0%B9)
            - [Ввод и вывод значений одномерного массива](#%D0%B2%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B9-%D0%BE%D0%B4%D0%BD%D0%BE%D0%BC%D0%B5%D1%80%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0)
            - [Ввод и вывод значений двумерные массива](#%D0%B2%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B4%D0%B2%D1%83%D0%BC%D0%B5%D1%80%D0%BD%D1%8B%D0%B5-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0)
            - [Ввод и вывод значений структуры](#%D0%B2%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B9-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B)
    - [[~] Создание и работа с массивами, символьными строками, матрицами, структурами](#-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D0%BC%D0%B8-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D1%8B%D0%BC%D0%B8-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0%D0%BC%D0%B8-%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0%D0%BC%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0%D0%BC%D0%B8)
        - [Работа с массивами](#%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D0%BC%D0%B8)
            - [Одномерные массивы](#%D0%BE%D0%B4%D0%BD%D0%BE%D0%BC%D0%B5%D1%80%D0%BD%D1%8B%D0%B5-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B)
            - [Перебор массивов](#%D0%BF%D0%B5%D1%80%D0%B5%D0%B1%D0%BE%D1%80-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%BE%D0%B2)
            - [Многомерные массивы](#%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BC%D0%B5%D1%80%D0%BD%D1%8B%D0%B5-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B)
            - [Динамические массивы](#%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B)
                - [Одномерный динамический массив](#%D0%BE%D0%B4%D0%BD%D0%BE%D0%BC%D0%B5%D1%80%D0%BD%D1%8B%D0%B9-%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2)
                - [Двумерный динамический массив](#%D0%B4%D0%B2%D1%83%D0%BC%D0%B5%D1%80%D0%BD%D1%8B%D0%B9-%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2)
        - [Работа с символными строками](#%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%BD%D1%8B%D0%BC%D0%B8-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0%D0%BC%D0%B8)
            - [[C++] std::strings строки](#c-stdstrings-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8)
                - [Конкатенация строк](#%D0%BA%D0%BE%D0%BD%D0%BA%D0%B0%D1%82%D0%B5%D0%BD%D0%B0%D1%86%D0%B8%D1%8F-%D1%81%D1%82%D1%80%D0%BE%D0%BA)
                - [Сравнение строк](#%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D1%82%D1%80%D0%BE%D0%BA)
                - [Размер строки](#%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%80-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8)
                - [Чтение строки с консоли](#%D1%87%D1%82%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8-%D1%81-%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D0%B8)
                - [Получение и изменение символов строки](#%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%BE%D0%B2-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8)
            - [[C] char[] и char* массивы как символьные строки](#c-char-%D0%B8-char-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B-%D0%BA%D0%B0%D0%BA-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8)
                - [Функции, для работы с Cи-строками](#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%B4%D0%BB%D1%8F-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B-%D1%81-c%D0%B8-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0%D0%BC%D0%B8)
                    - [Размер](#%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%80)
                    - [Копирование](#%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
                    - [Конкатенация](#%D0%BA%D0%BE%D0%BD%D0%BA%D0%B0%D1%82%D0%B5%D0%BD%D0%B0%D1%86%D0%B8%D1%8F)
                    - [Сравнение](#%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5)
                    - [Обработка символов](#%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%BE%D0%B2)
                    - [Функции поиска](#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0)
                    - [Функции преобразования](#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
                    - [Функции стандартной библиотеки ввода/вывода stdio](#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%BE%D0%B9-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8-%D0%B2%D0%B2%D0%BE%D0%B4%D0%B0%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0-stdio)
                    - [Работа с локалью](#%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D1%8E)
        - [Работа с матрицами](#%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0%D0%BC%D0%B8)
            - [Создание матрицы](#%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86%D1%8B)
            - [Ввод и вывод матрицы](#%D0%B2%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86%D1%8B)
            - [Удаление матрицы](#%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86%D1%8B)
            - [Операции с матрицами](#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8-%D1%81-%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0%D0%BC%D0%B8)
                - [Сложение матриц](#%D1%81%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86)
                - [Вычитание матриц](#%D0%B2%D1%8B%D1%87%D0%B8%D1%82%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86)
                - [Умножение матрицы на k](#%D1%83%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86%D1%8B-%D0%BD%D0%B0-k)
                - [Транспортирование матрицы](#%D1%82%D1%80%D0%B0%D0%BD%D1%81%D0%BF%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86%D1%8B)
            - [Примеры задач с матрицами](#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D1%8B-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87-%D1%81-%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0%D0%BC%D0%B8)
                - [Найти сумму элементов матрицы, лежащих выше главной диагонали](#%D0%BD%D0%B0%D0%B9%D1%82%D0%B8-%D1%81%D1%83%D0%BC%D0%BC%D1%83-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2-%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86%D1%8B-%D0%BB%D0%B5%D0%B6%D0%B0%D1%89%D0%B8%D1%85-%D0%B2%D1%8B%D1%88%D0%B5-%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D0%BE%D0%B9-%D0%B4%D0%B8%D0%B0%D0%B3%D0%BE%D0%BD%D0%B0%D0%BB%D0%B8)
                - [Проверить, является ли заданная квадратная матрица единичной](#%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%B8%D1%82%D1%8C-%D1%8F%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F-%D0%BB%D0%B8-%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F-%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F-%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0-%D0%B5%D0%B4%D0%B8%D0%BD%D0%B8%D1%87%D0%BD%D0%BE%D0%B9)
        - [Работа со структурами](#%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81%D0%BE-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0%D0%BC%D0%B8)
            - [Использование typedef](#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-typedef)
            - [Директива define](#%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%B0-define)
    - [[~] Работа с файлами](#-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0%D0%BC%D0%B8)
- [Создание функций](#%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9)
    - [[~] Выполнение функции](#-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)
    - [[~] Объявление функции](#-%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)
    - [[~] Оформление функций](#-%D0%BE%D1%84%D0%BE%D1%80%D0%BC%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9)
        - [Параметры функций](#%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9)
            - [Аргументы по умолчанию](#%D0%B0%D1%80%D0%B3%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-%D0%BF%D0%BE-%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E)
        - [Возвращение результата](#%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B5%D0%BD%D0%B8%D0%B5-%D1%80%D0%B5%D0%B7%D1%83%D0%BB%D1%8C%D1%82%D0%B0%D1%82%D0%B0)
    - [[~] Передача параметров в функцию: по значению, по указателю, по ссылке](#-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2-%D0%B2-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8E-%D0%BF%D0%BE-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8E-%D0%BF%D0%BE-%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8E-%D0%BF%D0%BE-%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B5)
        - [Передача параметров по значению](#%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2-%D0%BF%D0%BE-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8E)
        - [Передача параметров по ссылке](#%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2-%D0%BF%D0%BE-%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B5)
        - [Передача параметров по указателю](#%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2-%D0%BF%D0%BE-%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8E)
    - [[~] Перегрузка функций](#-%D0%BF%D0%B5%D1%80%D0%B5%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9)
        - [Типы возврата в перегрузке функций](#%D1%82%D0%B8%D0%BF%D1%8B-%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%82%D0%B0-%D0%B2-%D0%BF%D0%B5%D1%80%D0%B5%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9)
    - [[~] Рекрусивные функции](#-%D1%80%D0%B5%D0%BA%D1%80%D1%83%D1%81%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)
    - [[~] Библиотека функций для работы с символьными строками](#-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9-%D0%B4%D0%BB%D1%8F-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B-%D1%81-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D1%8B%D0%BC%D0%B8-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0%D0%BC%D0%B8)
- [Базовые алгоритмы](#%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B)
    - [[~] Алгоритмы обработки числовых данных](#-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8-%D1%87%D0%B8%D1%81%D0%BB%D0%BE%D0%B2%D1%8B%D1%85-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
        - [Вычисление ряда](#%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%80%D1%8F%D0%B4%D0%B0)
        - [Проверка на простоту](#%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B0-%D0%BD%D0%B0-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D1%82%D1%83)
        - [Определение делителей](#%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%B5%D0%BB%D0%B8%D1%82%D0%B5%D0%BB%D0%B5%D0%B9)
    - [[~] Алгоритмы обработки последовательностей](#-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8-%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9)
    - [[~] Алгоритмы работы с символьными строками](#-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B-%D1%81-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D1%8B%D0%BC%D0%B8-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0%D0%BC%D0%B8)
        - [Поиск слова максимальной длины](#%D0%BF%D0%BE%D0%B8%D1%81%D0%BA-%D1%81%D0%BB%D0%BE%D0%B2%D0%B0-%D0%BC%D0%B0%D0%BA%D1%81%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9-%D0%B4%D0%BB%D0%B8%D0%BD%D1%8B)
        - [Поиск количества вхождений заданного слова в строку](#%D0%BF%D0%BE%D0%B8%D1%81%D0%BA-%D0%BA%D0%BE%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B0-%D0%B2%D1%85%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D1%81%D0%BB%D0%BE%D0%B2%D0%B0-%D0%B2-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D1%83)
    - [[~] Алгоритмы работы с матрицами](#-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B-%D1%81-%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0%D0%BC%D0%B8)

<!-- /TOC -->
<!-- /TOC -->
# Не относящее к теме экзамена

## [~] Что же такое ваш этот C++?

### Описание языка C++ и его история

Язык программирования С++ представляет высокоуровневый компилируемый язык программирования общего назначения со статической типизацией, который подходит для создания самых различных приложений. На сегодняшний день С++ является одним из самых популярных и распространенных языков.

Своими корнями он уходит в язык Си, который был разработан в 1969—1973 годах в компании Bell Labs программистом Деннисом Ритчи (Dennis Ritchie). В начале 1980-х годов датский программист Бьерн Страуструп (Bjarne Stroustrup), который в то время работал в компании Bell Labs, разработал С++ как расширение к языку Си. Фактически вначале C++ просто дополнял язык Си некоторыми возможностями объектно-ориентированного программирования. И поэтому сам Страуструп вначале называл его как "C with classes" ("Си с классами").

Впоследствии новый язык стал набирать популярность. В него были добавлены новые возможности, которые делали его не просто дополнением к Си, а совершенно новым языком программирования. В итоге "Си с классами" был переименован в С++. И с тех по оба языка стали развиваться независимо друг от друга.

Текущий стандарт языка можно найти по ссылке [https://isocpp.org/](https://isocpp.org/)

С++ является мощным языком, унаследовав от Си богатые возможности по работе с памятью. Поэтому нередко С++ находит свое применение в системном программировании, в частности, при создании операционных систем, драйверов, различных утилит, антивирусов и т.д. К слову сказать, ОС Windows большей частью написана на С++. Но только системным программированием применение данного языка не ограничивается. С++ можно использовать в программах любого уровня, где важны скорость работы и производительность. Нередко он применяется для создания графических приложений, различных прикладных программ. Также особенно часто его используют для создания игр с богатой насыщенной визуализацией. Кроме того, в последнее время набирает ход мобильное направление, где С++ тоже нашел свое применение. И даже в веб-разработке также можно использовать С++ для создания веб-приложений или каких-то вспомогательных сервисов, которые обслуживают веб-приложения. В общем С++ - язык широкого пользования, на котором можно создавать практически любые виды программ.

С++ является компилируемым языком, а это значит, что компилятор транслирует исходный код на С++ в исполняемый файл, который содержит набор машинных инструкций. Но разные платформы имеют свои особенности, поэтому скомпилированные программы нельзя просто перенести с одной платформы на другую и там уже запустить. Однако на уровне исходного кода программы на С++ по большей степени обладают переносимостью, если не используются какие-то специфичные для текущей ос функции. А наличие компиляторов, библиотек и инструментов разработки почти под все распространенные платформы позволяет компилировать один и тот же исходный код на С++ в приложения под эти платформы.

В отличие от Си язык C++ позволяет писать приложения в объектно-ориентированном стиле, представляя программу как совокупность взаимодействующих между собой классов и объектов. Что упрощает создание крупных приложений.

### Основные этапы развития С++

В 1979-80 годах Бьерн Страуструп разработал расширение к языку Си - "Си с классами". В 1983 язык был переименован в С++.

В 1985 году была выпущена первая коммерческая версия языка С++, а также первое издание книги "Языка программирования C++", которая представляла первое описание этого языка при отсутствии официального стандарта.

В 1989 была выпущена новая версия языка C++ 2.0, которая включала ряд новых возможностей. После этого язык развивался относительно медленно вплоть до 2011 года. Но при этом в 1998 году была предпринята первая попытка по стандартизации языка организацией ISO (International Organiztion for Standartization). Первый стандарт получил название ISO/IEC 14882:1998 или сокращенно С++98. В дальнейшем в 2003 была издана новая версия стандарта C++03.

В 2011 году был издан новый стандарт C++11, который содержал множество добавлений и обогащал язык С++ большим числом новых функциональных возможностей. После этого в 2014 году было выпущено небольшое добавление к стандарту, известное также как C++14.

В 2017 уже вышел новый стандарт С++17, который добавил много новых возможностей и пересмотор на текущие решения в языке. В 2020 вышел стандарт С++20, дающий новые удобные функциональные решения и синтактический сахар(особо не решает в скорости, но удобен для записи програмистом). В 2023 намечен выход С++23.

### Компиляторы и среды разработки

Для разработки программ на С++ необходим компилятор - он транслирует исходный код на языке С++ в исполняемый файл, который затем можно запускать. Но в настоящий момент есть очень много различных компиляторов. Они могут отличаться по различным аспектам, в частности, по реализации стандартов. Базовый список компиляторов для С++ можно посмотреть в википедии. Рекомендуется для разработки выбирать те компиляторы, которые развиваются и реализуют все последние стандарты. Так, на протяжении всего руководства преимущественно будет использоваться свободно распространяемый компилятор g++, разработанный в рамках проекта GNU.

Также для создания программ можно использовать интегрированные среды разработки IDE, такие как Visual Studio, Code::Blocks, Eclipse, Qt Creator и т.д.

## [~] Локализация и кириллица в консоли

Если программа при выводе на консоль использует кириллицу, то мы можем столкнуться с ситуацией, когда вместо кириллических символов будут отображаются непонятные знаки. Особенно это актуально для ОС Windows. И в этом случае необходимо явным образом задать текущую локаль (культуру) для вывода символов. В языке C++ это можно сделать с помощью встроенной функции `setlocale()`.

Итак, код представляет собой вывод русского текста:

```c++
#include <iostream>
  
int main()
{
    std::cout << "Привет мир!";
    return 0;
}
```

Компиляция и запуск в ОС Windows может выглядеть следующим образом:

![image_locate_error](https://metanit.com/cpp/tutorial/pics/locale1.png)

Вместо ожидаемого текста я получаю какие-то непонятные символы. Теперь изменим код, применив функцию `setlocale`:

```c++
#include <iostream>
  
int main()
{
    setlocale(LC_ALL, "");
    std::cout << "Привет мир!";
    return 0;
}
```

Повторно компилируем и запустим приложение:

![image_locate_error](https://metanit.com/cpp/tutorial/pics/locale2.png)

Стоит отметить, что в качестве кодировки текстового файла в этом случае должна использоваться кодировка ANSI или Windows-1251, но не UTF-8.

## [~] Пространства имен и using

При чтении и записи использовались объекты `std::cout` и `std::cin` соответственно. Причем они использовались с префиксом `std::`. Этот префикс указывает, что объекты `cout`, `cin`, `endl` определены в пространствен имен `std`. А само двойное двоеточие `::` представляет оператор области видимости (scope operator), который позволяет указать, в каком пространсте имен определен объект/функция. И без префикса эти объекты по умолчанию мы использовать не можем.

Однако подобная запись может показаться несколько громоздкой. И в этом случае можно использовать оператор `using`, который позволяет ввести в программу объекты из различных пространств имен.

Использование оператора `using` имеет следующй формат:

```custom
using пространство_имен::объект
```

Например, пусть у нас есть следующая программа:

```c++
#include <iostream>
 
int main()
{   
    int age;
    std::cout << "Input age: ";
    std::cin >> age;
    std::cout << "Your age: " << age << std::endl;
    return 0;
}
```

Здесь используются сразу три объекта из програнства имен `std::cout`, `std::cin` и `std::endl`. Перепишем программу с использованием `using`:

```c++
#include <iostream>
using std::cin;
using std::cout;
using std::endl;
 
int main()
{   
    int age;
    cout << "Input age: ";
    cin >> age;
    cout << "Your age: " << age << endl;
    return 0;
}
```

Для каждого объекта из пространства `std` определяется свое выражение `using`. При этом программа будет работать также как и раньше.

# Синтаксические конструкции языка программирования С/С++

## [~] Типы данных

Каждая переменная имеет определенный тип. И этот тип определяет, какие значения может иметь переменная, какие операции с ней можно производить и сколько байт в памяти она будет занимать. В языке C++ определены следующие базовые типы данных:

**bool**: логический тип. Может принимать одну из двух значений true (истина) и false (ложь). Размер занимаемой памяти для этого типа точно не определен.

**char**: представляет один символ в кодировке ASCII. Занимает в памяти 1 байт (8 бит). Может хранить любое значение из диапазона от -128 до 127, либо от 0 до 255

**signed char**: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от -128 до 127

**unsigned char**: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от 0 до 255

**wchar_t**: представляет расширенный символ. На Windows занимает в памяти 2 байта (16 бит), на Linux - 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 65 535 (при 2 байтах), либо от 0 до 4 294 967 295 (для 4 байт)

**char16_t**: представляет один символ в кодировке Unicode. Занимает в памяти 2 байта (16 бит). Может хранить любой значение из диапазона от 0 до 65 535

**char32_t**: представляет один символ в кодировке Unicode. Занимает в памяти 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 4 294 967 295

**short**: представляет целое число в диапазоне от –32768 до 32767. Занимает в памяти 2 байта (16 бит).

Данный тип также имеет синонимы short int, signed short int, signed short.

**unsigned short**: представляет целое число в диапазоне от 0 до 65535. Занимает в памяти 2 байта (16 бит).

Данный тип также имеет синоним unsigned short int.

**int**: представляет целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита). Диапазон предельных значений соответственно также может варьироваться от –32768 до 32767 (при 2 байтах) или от −2 147 483 648 до 2 147 483 647 (при 4 байтах). Но в любом случае размер должен быть больше или равен размеру типа short и меньше или равен размеру типа long

Данный тип имеет синонимы signed int и signed.

**unsigned int**: представляет положительное целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита), и из-за этого диапазон предельных значений может меняться: от 0 до 65535 (для 2 байт), либо от 0 до 4 294 967 295 (для 4 байт).

В качестве синонима этого типа может использоваться unsigned

**long**: представляет целое число в диапазоне от −2 147 483 648 до 2 147 483 647. Занимает в памяти 4 байта (32 бита).

У данного типа также есть синонимы long int, signed long int и signed long

**unsigned long**: представляет целое число в диапазоне от 0 до 4 294 967 295. Занимает в памяти 4 байта (32 бита).

Имеет синоним unsigned long int.

**long long**: представляет целое число в диапазоне от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807. Занимает в памяти, как правило, 8 байт (64 бита).

Имеет синонимы long long int, signed long long int и signed long long.

**unsigned long long**: представляет целое число в диапазоне от 0 до 18 446 744 073 709 551 615. Занимает в памяти, как правило, 8 байт (64 бита).

Имеет синоним unsigned long long int.

**float**: представляет вещественное число ординарной точности с плавающей точкой в диапазоне +/- 3.4E-38 до 3.4E+38. В памяти занимает 4 байта (32 бита)

**double**: представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 1.7E-308 до 1.7E+308. В памяти занимает 8 байт (64 бита)

**long double**: представляет вещественное число двойной точности с плавающей точкой не менее 8 байт (64 бит). В зависимости от размера занимаемой памяти может отличаться диапазон допустимых значений.

**void**: тип без значения

Таким образом, все типы данных за исключением **void** могут быть разделены на три группы: **символьные** (char, wchar_t, char16_t, char32_t), **целочисленные** (short, int, long, long long) и **типы чисел с плавающей точкой** (float, double, long double).

### Символьные типы

Для представления символов в приложении используются типы *char, wchar_t, char16_t и char32_t*.

Определим несколько переменных:

```c++
char c ='d';
wchar_t d ='c';
```

Переменная типа *char* в качестве значения принимает один символ в одинарных кавычках: `char c ='d'`. Также можно присвоить число из указанного выше в списке диапазона: `char c = 120`. В этом случае значением переменной c будет тот символ, который имеет код 120 в таблице символов [ASCII](https://devdocs.io/cpp/language/ascii).

[Таблица ASCII](https://devdocs.io/cpp/language/ascii) (Только английские символы + спец символы.)

Стоит учитывать, что для вывода на консоль символов *wchar_t* следует использовать не `std::cout`, а поток `std::wcout`:

```c++
# include <iostream>

int main()
{
    char a = 'H';
    wchar_t b = 'e';
    std::wcout << a << b << '\n';
    return 0;
}
```

При этом поток `std::wcout` может работать как с *char*, так и с *wchar_t*. А поток `std::cout` для переменной *wchar_t* вместо символа будет выводить его числовой код.

В стандарте **С++11** были добавлены типы *char16_t* и *char32_t*, которые ориентированы на использование Unicode. Однако на уровне ОС пока не реализованы потоки для работы с этими типами. Поэтому если потребуется вывести на консоль значения переменных этих типов, то необходимо преобразовать переменные к типам *char* или *wchar_t*:

```c++
# include <iostream>

int main()
{
    char a = 'H';
    wchar_t b = 'e';
    char16_t c = 'l';
    char32_t d = 'o';
    std::cout << a << (char)b << (char)c << (char)d << "\n";
    return 0;
}
```

В данном случае при выводе перед переменными указывается операция приведения к типу *char* - `(char)`, благодаря чему значения переменных b, c и d преобразуются в тип *char* и могут быть выведены на консоль с помощью потока `std::cout`.

### Целочисленные типы

Целочисленные типы представлены следующими типами: *short, unsigned short, int, unsigned int, long, unsigned long, long long и unsigned long long*:

```c++
short a = -10;
unsigned short b = 10;
int c = -30;
unsigned int d = 60;
long e = -170;
unsigned long f = 45;
long long g = 89;
```

### Типы чисел с плавающей точкой

Типы чисел с плавающей точкой или дробные числа представлены такими типами как *float, double и long double*:

```c++
float a = -10.45;
double b = 0.00105;
long double c = 30.890045;
```

### Размеры типов данных

В выше приведенном списке для каждого типа указан размер, который он занимает в памяти. Однако стоит отметить, что предельные размеры для типов разработчики компиляторов могут выбирать самостоятельно, исходя из аппаратных возможностей компьютера. Стандарт устанавливает лишь минимальные значения, которые должны быть. Например, для типов *int* и *short* минимальное значение - 16 бит, для типа *long* - 32 бита, для типа *long double*. При этом размер типа *long* должен быть не меньше размера типа *int*, а размер типа *int* - не меньше размера типа *short*, а размер типа *long double* должен быть больше *double*. К примеру, компилятор g++ под Windows для *long double* использует 12 байт, а компилятор, встроенный в Visual Studio и также работающий под Windows, для *long double* использует 8 байт. То есть даже в рамках одной платформы разные компиляторы могут по разному подходить к размерам некоторых типов данных. Но в целом используются те размеры, которые указаны выше при описании типов данных.

Однако бывают ситуации, когда необходимо точно знать размер определенного типа. И для этого в С++ есть оператор `sizeof()`, который возвращает размер памяти в байтах, которую занимает переменная:

```c++
# include <iostream>

int main()
{
    long double number = 2;
    std::cout << "> sizeof(number) =" << sizeof(number);
    return 0;
}
```

Консольный вывод при компиляции в g++:

`> sizeof(number) = 12`

При этом при определении переменных важно понимать, что значение переменной не должно выходить за те пределы, которые очерчены для ее типа. Например:

`unsigned short number = -65535;`

Компиляция такого кода может пройти без ошибок, хотя некоторые компиляторы, как G++ могут выдавать предупреждения о том, что значение будет усечено. Однако при комиляции переменная number получит значение 1 - результат преобразования числа -65535 к типу *unsigned short*. То есть опять же результат будет не совсем тот, который ожидается. Значение переменной - это всего лишь набор битов в памяти, которые интерпретируются в соответствии с определенным типом. И для разных типов один и тот же набор битов может интерпретироваться по разному. Поэтому важно учитывать диапазоны значений для того или иного типа при присвоении переменной значения.

### Спецификатор auto

Иногда бывает трудно определить тип выражения. И согласно последним стандартам можно предоставить компилятору самому выводить тип объекта. И для этого применяется спецификатор auto. При этом если мы определяем переменную со спецификатором auto, эта переменная должна быть обязательно инициализирована каким-либо значением:

`auto number = 5;`
На основании присвоенного значения компилятор выведет тип переменной. Неинициализированные переменные со спецификатором auto не допускаются:

`auto number; // [Error] Ошибка! Нельзя использовать auto в неиницилизированных переменных.`

## [~] Определение переменных

Как и во многих языках программирования, в C++ для хранения данных используются переменные. Переменная имеет тип, имя и значение. Тип определяет, какую информацию может хранить переменная.

Перед использованием любую переменную надо определить. Синтаксис определения переменной выглядит следующим образом:

```c++
тип_переменной имя_переменной;
```

Простейшее определение переменной:

```c++
int age;
```

Здесь определена переменная age, которая имеет тип int. Поскольку определение переменной представляет собой инструкцию, то после него ставится точка с запятой.

Также стоит учитывать, что C++ - **регистрозависимый** язык, а это значит, что регистр символов имеет большое значение. То есть в следующем коде будут определяться две разные переменные:

```c++
int age;
int Age;
```

Поэтому переменная Age не будет представлять то же самое, что и переменная age.

Кроме того, в качестве имени переменной нельзя использовать ключевые слова языке C++, например, **for** или **if**. Но таких слов не так много: **alignas, alignof, asm, auto, bool, break, case, catch, char, char16_t, char32_t, class, const, constexpr, const_cast, continue, decltype, default, delete, do, double, dynamic_cast, else, enum, explicit, export, extern, false, float, for, friend, goto, if, inline, int, long, mutubale, namespace, new, noexcept, nullptr, operator, private, protected, public, register, reinterpret_cast, return, short, signed, sizeof, static, static_assert, static_cast, struct, switch, template, this, thread_local, throw, true, try, typedef, typeid, typename, union, unsigned, using, virtual, void, volatile, wchar_t, while**.

Также нельзя объявить больше одной переменной с одним и тем же именем, например:

```c++
int age;
int age;
```

Подобное определение вызовет ошибку на этапе компиляции.

И в довершеие следует сказать, что переменным стоит давать осмысленные имена, которые будут говорить об их предназначении.

Инициализация
После определения переменной можно присвоить некоторое значение:

```c++
int age;
age = 20;
```

Например, определим в прогамме переменную и выведем ее значение на консоль:

```c++
#include <iostream>
 
int main()
{
    int age;
    age = 28;
    std::cout<<"Age = " << age;
    return 0;
}
```

С помощью последовательности операторов `<<` можно вывести несколько значений на консоль.

После компиляции и запуска скомпилированной программы на консоль будет выведено число `28`.

Однако также можно сразу при определении переменной дать ей некоторое начальное значение. Данный прием называется инициализацией, то есть присвоение переменной начального значения:

```c++
#include <iostream>
 
int main()
{
    int age = 28;
    std::cout<<"Age = " << age;
    return 0;
}
```

### Инициализация по умолчанию

Если переменную не инициализировать, то происходит ее инициализация по умолчанию. И переменная получает некоторое значение по умолчанию, которое зависит от места, где эта переменная определена.

Если переменная, которая представляет встроенный тип (например, тип *int*), определена внутри функции, то она получает неопределенное значение. Если переменная встроенного типа определена вне функции, то она получает то значение по умолчанию, которое соответствует ее типу. Для числовых типов это число `0`. Например:

```c++
#include <iostream>
 
int x;
int main()
{
    int y;
    std::cout <<"X = " << x << "\n";
    std::cout <<"Y = " << y;
     
    return 0;
}
```

Переменная x определена вне функции, и поэтому она получит значение по умолчанию - число `0`.

Гораздо сложнее дело обстоит с переменной y, которая определена внутри функции main - ее значение будет неопределенным, и многое будет зависеть от используемого компилятора. В частности, вывод программы, скомпилированной с помощью компилятора G++, может выглядеть следующим образом:

```c
X = 0
Y = 4200475
```

А в Visual Studio отсутствие значения переменной y вызовет ошибку.

**Но в любом случае перед использованием переменной лучше явным образом назначать ей определенное значение, а не полагаться на значение по умолчанию.**

### Изменение значения

Ключевой особенностью переменных является то, что мы можем изменять их значения:

```c++
#include <iostream>
 
int main()
{
    int x = 6;
    x = 8;
    x = 10;
    std::cout <<"X = " << x; // X = 10
     
    return 0;
}
```

### Константы

Отличительной особенностью обычных переменных является то, что мы можем многократно в течение работы программы изменять их значение:

```c++
int x = 7;
x = 9;
x = 5;
```

Но кроме переменных в языке программирования C++ можно определять константы. Их значение устанавливается один раз и впоследствии мы его не можем изменить. Константа определяется практически также, как и переменная за тем исключением, что в начале определения константы идет ключевое слово *const*. Например:

```c++
const int x = 22;
std::cout << x;
```

Если же мы захотим после определения константы присвоить ей некоторое значение, то компилятор не сможет скомпилировать программу и выведет ошибку:

```c++
const int x = 22;
x = 78; // [Error] Ошибка! Идет присвоение значения к константной переменной!
```

То есть такой код не будет работать. И так как нельзя изменить значения константы, то ее всегда необходимо инициализировать, если мы хотим, чтобы она имела некоторое значение.

Если константа не будет инициализирована, то компилятор также выведет ошибку и не сможет скомпилировать программу, как в следующем случае:

```C++
const int x; // [Error] Ошибка! Переменная не иницилизирована!
```

В качестве значения константам можно передавать как обычные литералы, так и динамически вычысляемые значения, например, значения переменных или других констант:

```c++
int a = 10;
const int b = 7;
const int d = b;
const int x = a;
```

Обычно в качестве констант определяются такие значения, которые должны оставаться постоянными в течение работы всей программы и не могут быть изменены. Например, если программы выполняет математические операции с использованием числа **PI**, то было бы оптимально определить данные значение как константу, так как оно все равно в принципе неизменно:

```c++
const float pi = 3.14;
```

## [~] Операции и их использование в выражениях

### Арифметические операции

Арифметические операции производятся над числами. Значения, которые участвуют в операции, называются операндами. В языке программирования C++ арифметические операции **бинарными** (производятся над двумя операндами) и **унарными** (выполняются над одним операндом).

**К бинарным операциям относят следующие:**

#### `+`

Операция сложения возвращает сумму двух чисел:

```C++
int a = 10;
int b = 7;
int c = a + b;  // 17
int d = 4 + b;  // 11
```

#### `-`

Операция вычитания возвращает разность двух чисел:

```C++
int a = 10;
int b = 7;
int c = a - b;  // 3
int d = 41 - b; // 34
```

#### `*`

Операция умножения возвращает произведение двух чисел:

```C++
int a = 10;
int b = 7;
int c = a * b;  // 70
int d = b * 5;  // 35
```

#### `/`

Операция деления возвращает частное двух чисел:

```C++
int a = 20;
int b = 5;
int c = a / b;  // 4
double d = 22.5 / 4.5;  // 5
```

При делении стоит быть внимательным, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа, даже если результат присваивается переменной *float* или *double*:

```c++
double k = 10 / 4;     // 2
std::cout << k;
```

Чтобы результат представлял числос плавающей точкой, один из операндов также должен представлять число с плавающей точкой:

```c++
double k = 10.0 / 4;     // 2.5
std::cout << k;
```

#### `%`

Операция получения остатка от целочисленного деления:

```c++
int a = 33;
int b = 5;
int c = a % b;  // 3
int d = 22 % 4; // 2 (22 - 4*5 = 2)
```

Также есть **две унарные арифметические операции**, которые производятся над одним числом: *++* (инкремент) и *--* (декремент). Каждая из операций имеет две разновидности: префиксная и постфиксная:

#### Префиксный инкремент

Увеличивает значение переменной на единицу и полученный результат используется как значение выражения ++x

```c++
int a = 8;
int b = ++a;
std::cout << a << "\n"; // 9
std::cout << b << "\n"; // 9
```

#### Постфиксный инкремент

Увеличивает значение переменной на единицу, но значением выражения x++ будет то, которое было до увеличения на единицу

```c++
int a = 8;
int b = a++;
std::cout << a << "\n"; // 9
std::cout << b << "\n"; // 8
```

#### Префиксный декремент

Уменьшает значение переменной на единицу, и полученное значение используется как значение выражения --x

```c++
int a = 8;
int b = --a;
std::cout << a << "\n"; // 7
std::cout << b << "\n"; // 7
```

#### Постфиксный декремент

Уменьшает значение переменной на единицу, но значением выражения x-- будет то, которое было до уменьшения на единицу

```c++
int a = 8;
int b = a--;
std::cout << a << "\n"; // 7
std::cout << b << "\n"; // 8
```

Арифметические операции вычисляются слева направо. Одни операции имеют больший приоритет чем другие и поэтому выполняются вначале. Операции в порядке уменьшения приоритета:

```custom
+ (инкремент), - (декремент)
* (умножение), / (деление), % (остаток от деления)
+ (сложение), - (вычитание)
```

Приоритет операций следует учитывать при выполнении набора арифметических выражений:

```c++
int a = 8;
int b = 7;
int c = a + 5 * ++b;      // 48
std::cout << c;
```

Хотя операции выполняются слева направо, но вначале будет выполняться операция инкремента `++b`, которая увеличит значение переменной *b* и возвратит его в качестве результата, так как эта операция имеет больший приоритет. Затем выполняется умножение `5 * ++b`, и только в последнюю очередь выполняется сложение `a + 5 * ++b`

Скобки позволяют переопределить порядок вычислений. Например:

```c++
int a = 8;
int b = 7;
int c = (a + 5) * ++b;      // 104
std::cout << c;
```

Несмотря на то, что операция сложения имеет меньший приоритет, но вначале будет выполняться именно сложение, а не умножение, так как операция сложения заключена в скобки.
___

### Битовые операторы

Побитовые операции выполняются над отдельными разрядами или битами чисел. Данные операции производятся только над целыми числами.

#### Операции сдвига

Каждое целое число в памяти представлено в виде определенного количества разрядов. И операции сдвига позволяют сдвинуть битовое представление числа на несколько разрядов вправо или влево. Операции сдвига применяются только к целочисленным операндам. Есть две операции:

##### `<<`

Сдвигает битовое представление числа, представленного первым операндом, влево на определенное количество разрядов, которое задается вторым операндом.

##### `>>`

Сдвигает битовое представление числа вправо на определенное количество разрядов.

Применение операций:

```C++
int a = 2 << 2;           // 10  на два разрядов влево = 1000 - 8
int b = 16 >> 3;          // 10000 на три разряда вправо = 10 - 2
```

Число 2 в двоичном представлении 10. Если сдвинуть число 10 на два разряда влево, то получится 1000, что в десятичной системе равно число 8.

Число 16 в двоичном представлении 10000. Если сдвинуть число 10 на три разряда вправо (три последних разряда отбрасываются), то получится 10, что в десятичной системе представляет число 2.

#### Поразрядные операции

Поразрядные операции также проводятся только над соответствующими разрядами целочисленных операндов:

**`&`**: поразрядная конъюнкция (операция И или поразрядное умножение). Возвращает 1, если оба из соответствующих разрядов обоих чисел равны 1

**`|`**: поразрядная дизъюнкция (операция ИЛИ или поразрядное сложение). Возвращает 1, если хотя бы один из соответствующих разрядов обоих чисел равен 1

**`^`**: поразрядное исключающее ИЛИ. Возвращает 1, если только один из соответствующих разрядов обоих чисел равен 1

**`~`**: поразрядное отрицание или инверсия. Инвертирует все разряды операнда. Если разряд равен 1, то он становится равен 0, а если он равен 0, то он получает значение 1.

Применение операций:

```C++
int a = 5 | 2;          // 101 | 010 = 111  - 7
int b = 6 & 2;          // 110 & 010 = 10  - 2
int c = 5 ^ 2;          // 101 ^ 010 = 111 - 7
int d = ~9;             // -10
```

Например, выражение  `5 | 2` равно `7`. Число `5` в двоичной записи равно 101, а число `2` - `10` или `010`. Сложим соответствующие разряды обоих чисел. При сложении если хотя бы один разряд равен `1`, то сумма обоих разрядов равна `1`. Поэтому получаем:

```c
1 0 1
0 1 0
1 1 1
```

В итоге получаем число `111`, что в десятичной записи представляет число `7`.

Возьмем другое выражение `6 & 2`. Число *6* в двоичной записи равно *110*, а число *2* - *10* или *010*. Умножим соответствующие разряды обоих чисел. Произведение обоих разрядов равно *1*, если оба этих разряда равны *1*. Иначе произведение равно *0*. Поэтому получаем:

```C
1 1 0
0 1 0
0 1 0
```

Получаем число *010*, что в десятичной системе равно *2*.

## [~] Операторы

### Условный оператор

Условные конструкции направляют ход программы по одному из возможных путей в зависимости от условия.

#### Конструкция if

Конструкция if проверяет истинность условия, и если оно истинно, выполняет блок инструкций. Этот оператор имеет следующую сокращенную форму:

```custom
if (условие)
{
    инструкции;
}
```

В качестве условия использоваться условное выражение, которое возвращает *true* или *false*. Если условие возвращает *true*, то выполняются последующие инструкции, которые входят в блок `if`. Если условие возвращает *false*, то последующие инструкции не выполняются. Блок инструкций заключается в фигурные скобки.

Например:

```c++
#include <iostream>
 
int main()
{
    int x = 60;
      
    if(x > 50)
    {
        std::cout << "x is greater than 50 \n";
    }
      
    if(x < 30)
    {
        std::cout << "x is less than 30 \n";
    }
     
    std::cout << "End of Program" << "\n";
    return 0;
}
```

Здесь определены две условных конструкции `if`. Они проверят больше или меньше значение переменной *x*, чем определенное значение. В качестве инструкции в обоих случаях выполняется вывод некоторой строки на консоль.

В первом случае `x > 50` условие истинно, так как значение переменной *x* действительно больше `50`, поэтому это условие возвратит *true*, и, следовательно, будут выполнятся инструкции, которые входят в блок `if`.

Во втором случае операция отношения `x < 30` возвратит *false*, так как условие ложно, поэтому последующий блок инструкций выполняться не будет. В итоге при запуске программы вывод консоли будет выглядеть следующим образом:

```custom
x greater than 50
End of Program
```

Также мы можем использовать полную форму конструкции `if`, которая включает оператор `else`:

```custom
if(выражение_условия)
    инструкция_1
else
    инструкция_2
```

После оператора `else` мы можем определить набор инструкций, которые выполняются, если условие в операторе `if` возвращает *false*. То есть если условие истинно, выполняются инструкции после оператора `if`, а если это выражение ложно, то выполняются инструкции после оператора `else`.

```c++
int x = 50;
if(x > 60) 
    std::cout << "x is greater than 60 \n";
else
    std::cout << "x is less or equal 60 \n";
```

В данном случае условие `x > 60` ложно, то есть возвращает *false*, поэтому будет выполняться блок `else`. И в итоге на консоль будет выведена строка `"x is less or equal 60 \n"`.

Однако нередко надо обработать не два возможных альтернативных варианта, а гораздо больше. Например, в случае выше можно насчитать три условия: переменная *x* может быть больше `60`, меньше `60` и равна `60`. Для проверки альтернативных условий мы можем вводить выражения `else if`:

```c++
int x = 60;
     
if(x > 60)
{
    std::cout << "x is greater than 60 \n";
}
else if (x < 60)
{
    std::cout << "x is less than 60 \n";
}
else
{
    std::cout << "x is equal 60 \n";
}
```

То есть в данном случае мы получаем три ветки развития событий в программе.

Если в блоке `if` или `else` или `else-if` необходимо выполнить только одну инструкцию, то фигурные скобки можно опустить:

```c++
int x = 60;
     
if(x > 60)
    std::cout << "x is greater than 60 \n";
else if (x < 60)
    std::cout << "x is less than 60 \n";
else
    std::cout << "x is equal 60 \n";
    
```

#### Конструкция switch

Другую форму организации ветвления программ представляет конструкция `switch...case`. Она имеет следующую форму:

```custom
switch(выражение)
{
    case константа_1: инструкции_1;
    case константа_2: инструкции_2;
     
    default: инструкции;
}
```

После ключевого слова `switch` в скобках идет сравниваемое выражение. Значение этого выражения последовательно сравнивается со значениями после оператора `сase`. И если совпадение будет найдено, то будет выполняться определенный блок `сase`.

В конце конструкции `switch` может стоять блок `default`. Он необязателен и выполняется в том случае, если значение после `switch` не соответствует ни одному из операторов `case`. Например:

```c++
#include <iostream>
 
int main()
{
    int x = 2;
      
    switch(x)
    {
        case 1: 
            std::cout << "x = 1" << "\n";
            break;
        case 2: 
            std::cout << "x = 2" << "\n";
            break;
        case 3: 
            std::cout << "x = 3" << "\n";
            break;
        default: 
            std::cout << "x is undefined" << "\n";
            break;
    }
    return 0;
}
```

Чтобы избежать выполнения последующих блоков `case/default`, в конце каждого блока ставится оператор `break`. То есть в данном случае будет выполняться оператор

```c++
case 2: 
    std::cout << "x = 2" << "\n";
    break;
```

После выполнения оператора `break` произойдет выход из конструкции `switch..case`, и остальные операторы `case` будут проигнорированы. Поэтому на консоль будет выведена следующая строка:
```x = 2```

Стоит отметить важность использования оператора `break`. Если мы его не укажем в блоке `case`, то после этого блока выполнение перейдет к следующему блоку `case`. Например, уберем из предыдущего примера все операторы `break`:

```c++
#include <iostream>
 
int main()
{
    int x = 2;
      
    switch(x)
    {
        case 1: 
            std::cout << "x = 1" << "\n";
        case 2: 
            std::cout << "x = 2" << "\n";
        case 3: 
            std::cout << "x = 3" << "\n";
        default: 
            std::cout << "x is undefined" << "\n";
    }
    return 0;
}
```

В этом случае опять же будет выполняться оператор `case 2:`, так как переменная `x=2`. Однако так как этот блок `case` не завершается оператором `break`, то после его завершения будет выполняться набор инструкций после `case 3`: даже несмотря на то, что переменная *x* по прежнему равна `2`. В итоге мы получим следующий консольный вывод:

```c
x = 2
x = 3
x is undefined
```

#### Тернарный оператор

Тернарный оператор `?:` позволяет сократить определение простейших условных конструкций if и имеет следующую форму:

`[первый операнд - условие] ? [второй операнд] : [третий операнд]`

Оператор использует сразу три операнда. В зависимости от условия тернарный оператор возвращает второй или третий операнд: если условие равно *true* (то есть истинно), то возвращается второй операнд; если условие равно *false* (то есть ложно), то третий. Например:

```c++
#include <iostream>
 
int main()
{
    setlocale(LC_ALL, "");
    int x = 5; 
    int y = 3;
    char sign;
    std::cout << "Введите знак операции: ";
    std::cin >> sign;
    int result = sign=='+'?x + y:x - y;
    std::cout << "Результат: " << result << "\n";
    return 0;
}
```

В данном случае производится ввод знака операции. Здесь результатом тернарной операции является переменная `result`. И если переменная sign содержит знак "+", то `result` будет равно второму операнду - `(x+y)`. Иначе `result` будет равно третьему операнду.

Чтобы понять как точно работает тернарный оператор, имеется пример с использованием конструкции `if`:

```c++
int main()
{
    bool a = true;
    int b;
    if(a) // Аналогично (a == true)
    {
        b = 1;
    }
    else
    {
        b = 2;
    }
    cout << b; 
}
```

Вывод в консоли:
`1`

Перепишем с использованием тернатного оператора:

```c++
int main()
{
    bool a = true;
    int b;
    b = a ? 1 : 2;
    cout << b; 
}
```

Вывод в консоли:
`1`

### Цикл с условием

Для выполнения некоторых действий множество раз в зависимости от определенного условия используются циклы. В языке C++ имеются следующие виды циклов:

- `while`
- `for`
- `do...while`

#### Цикл while

Цикл `while` выполняет некоторый код, пока его условие истинно, то есть возвращает *true*. Он имеет следующее формальное определение:

```custom
while(условие)
{
    // выполняемые действия
}
```

После ключевого слова `while` в скобках идет условное выражение, которое возвращает *true* или *false*. Затем в фигурных скобках идет набор инструкций, которые составляют тело цикла. И пока условие возвращает *true*, будут выполняться инструкции в теле цикла.

Например, выведем квадраты чисел от 1 до 9:

```c++
#include <iostream>
 
int main()
{   
    int i = 1;
    while(i < 10)
    {
        std::cout << i << " * " << i << " = " << i * i << std::endl;
        i++;
    }
     
    return 0;
}
```

Здесь пока условие `i < 10` истинно, будет выполняться цикл `while`, в котором выводится на консоль квадрат числа и инкрементируется переменная *i*. В какой-то момент переменная *i* увеличится до `10`, условие `i < 10` возвратит *false*, и цикл завершится.

Консольный вывод программы:

```c
1 * 1 = 1
2 * 2 = 4
3 * 3 = 9
4 * 4 = 16
5 * 5 = 25
6 * 6 = 36
7 * 7 = 49
8 * 8 = 64
9 * 9 = 81
```

Каждый отдельный проход цикла называется итерацией. То есть в примере выше было 9 итераций.

Если цикл содержит одну инструкцию, то фигурные скобки можно опустить:

```c++
int i = 0;
while(++i < 10)
    std::cout << i << " * " << i << " = " << i * i << std::endl;
```

#### Цикл for

Цикл for имеет следующее формальное определение:

```custom
for (выражение_1; выражение_2; выражение_3)
{
    // тело цикла
}
```

**выражение_1** выполняется один раз при начале выполнения цикла и представляет установку начальных условий, как правило, это инициализация счетчиков - специальных переменных, которые используются для контроля за циклом.

**выражение_2** представляет условие, при соблюдении которого выполняется цикл. Как правило, в качестве условия используется операция сравнения, и если она возвращает ненулевое значение (то есть условие истинно), то выполняется тело цикла, а затем вычисляется выражение_3.

**выражение_3** задает изменение параметров цикла, нередко здесь происходит увеличение счетчиков цикла на единицу.

Например, перепишем программу по выводу квадратов чисел с помощью цикла `for`:

```c++
#include <iostream>
 
int main()
{   
    for(int i = 1; i < 10; i++)
    {
        std::cout << i << " * " << i << " = " << i * i << std::endl;
    }
     
    return 0;
}
```

Первая часть объявления цикла - `int i = 1` - создает и инициализирует счетчик *i*. Фактически это то же самое, что и объявление и инициализация переменной. Счетчик необязательно должен представлять тип `int`. Это может быть и другой числовой тип, например, `float`. И перед выполнением цикла его значение будет равно `1`.

Вторая часть - условие, при котором будет выполняться цикл. В данном случае цикл будет выполняться, пока переменная `i` не станет равна `10`.

И третья часть - приращение счетчика на единицу. Опять же нам необязательно увеличивать на единицу. Можно уменьшать: `i--`. Можно изменять на другое значение: `i+=2`.

В итоге блок цикла сработает `9` раз, пока переменная *i* не станет равна `10`. И каждый раз это значение будет увеличиваться на `1`. И по сути мы получим тот же самый результат, что и в случае с циклом `while`:

```c++
1 * 1 = 1
2 * 2 = 4
3 * 3 = 9
4 * 4 = 16
5 * 5 = 25
6 * 6 = 36
7 * 7 = 49
8 * 8 = 64
9 * 9 = 81
```

Необязательно указывать все три выражения в определении цикла, мы можем одно или даже все из них опустить:

```C++
int i = 1;
for(; i < 10;)
{
    std::cout << i << " * " << i << " = " << i * i << std::endl;
    i++;
}
```

Формально определение цикла осталось тем же, только теперь первое и третье выражения в определении цикла отсутствуют: `for (; i < 10;)`

Переменная-счетчик определена и инициализирована вне цикла, а ее приращение происходит в самом цикле.

Можно определять вложенные циклы. Например, выведем таблицу умножения:

```C++
#include <iostream>
 
int main()
{   
    for (int i=1; i < 10; i++)
    {
        for(int j = 1; j < 10; j++)
        {
            std::cout << i * j << "\t";
        }
        std::cout << std::endl;
    }
     
    return 0;
}
```

Таблица умножения на языке C++ в консоли:

![image](https://metanit.com/cpp/tutorial/pics/2.1.png)

#### Цикл do

В цикле `do` сначала выполняется код цикла, а потом происходит проверка условия в инструкции `while`. И пока это условие истинно, то есть не равно `0`, то цикл повторяется. Формальное определение цикла:

```custom
do
{
    инструкции
}
while(условие);
```

Например:

```C++
#include <iostream>
 
int main()
{   
    int i = 6;
    do
    {
        std::cout << i << std::endl;
        i--;
    }
    while(i > 0);
     
    return 0;
}
```

Здесь код цикла сработает 6 раз, пока *i* не станет равным нулю.

Но важно отметить, что цикл do гарантирует хотя бы однократное выполнение действий, даже если условие в инструкции `while` не будет истинно. То есть мы можем написать:

```c++
int i = -1;
do
{
    std::cout << i << std::endl;
    i--;
}
while(i > 0);
```

Хотя у нас переменная *i* меньше 0, цикл все равно один раз выполнится.

### Цикл с параметром

С.м цикл `for`.

Особенность данного цикла является то, что (другое его название - цикл по переменной) позволяет выполнить набор команд фиксированное число раз, т.е. число итераций должно быть известно до начала выполнения цикла. Особенностью данного цикла является то, что заводится специальная переменная-счётчик, которая последовательно проходит указанный диапазон значений.

### Операторы передачи управления (break, continue, return)

#### Операторы continue и break

Иногда возникает необходимость выйти из цикла до его завершения. В этом случае можно воспользоваться оператором `break`. Например:

```c++
#include <iostream>
 
int main()
{
    int i = 1;
    for ( ; ; )
    {
        std::cout << i << " * " << i << " = " << i * i << std::endl;
        i++;
        if (i > 9) break;
    }
    return 0;
}
```

Здесь когда значение переменной `i` достигнет `10`, осуществляется выход из цикла с помощью оператора `break`.

В отличие от оператора `break`, оператор `continue` производит переход к следующей итерации. Например, нам надо посчитать сумму только нечетных чисел из некоторого диапазона:

```c++
#include <iostream>
int main()
{
    int result = 0;
    for (int i=0; i<10; i++)
    {
        if (i % 2 == 0) continue;
        result +=i;
    }
    std::cout << "result = " << result << std::endl; // 25
    return 0;
}
```

Чтобы узнать, четное ли число, мы получаем остаток от целочисленного деления на 2, и если он равен 0, то с помощью оператора `continue` переходим к следующей итерации цикла. А если число нечетное, то складываем его с остальными нечетными числами.

#### Оператор return

Для возвращения результата из функции применяется оператор return. Этот оператор имеет две формы:

```custom
return;
return выражение;
```

Первая форма используется, если в качестве возвращаемого типа функции применяется тип `void`. Например:

```c++
#include <iostream>
 
void factorial(int);
 
int main()
{
    factorial(-3);
    factorial(5);
    factorial(4);
    return 0;
}
 
void factorial(int n)
{
    if(n<1)
    {
        std::cout << "Incorrect number" << std::endl;
        return;
    }
    int result = 1;
    for(int i = 1; i <=n; i++)
    {
        result *= i;
    }
    std::cout << "Factorial of " << n << " is equal to " << result << std::endl;
}
```

В данном случае функция `factorial` вычисляет факториал переданного числа. Однако если число меньше `1`, то функция выводит соответствующее сообщение, и с помощью оператора return осуществляется выход из функции.

Вторая форма оператора `return` применяется для возвращения результата из функции. Если функция имеет в качестве возвращаемого типа любой тип, отличный от `void`, то такая функция обязятельно должна возвратить некоторое значение с помощью оператора `return`. Причем значение, которое возвращается оператором `return`, должно соответствовать возвращаемому типу функции, либо допускать неявное преобразование в этот тип.

Например, возвратим из функции факториал числа:

```c++
#include <iostream>
 
int factorial(int);
 
int main()
{
    int n = 5;
    int result = factorial(n);
    std::cout << "Factorial of " << n << " is equal to " << result << std::endl;
    return 0;
}

int factorial(int n)
{
    int result = 1;
    for(int i = 1; i <=n; i++)
    {
        result *= i;
    }
    return result;
}
```

Так как функция `factorial` возвращает значение, то ее результат можно присвоить какой-нибудь переменной или константе:

```int result = factorial(n);```

##### Возвращение ссылки

Не следует возвращать ссылку на локальный объект, который создается внутри функции. Поскольку все создаваемые в функции объекты удаляются после ее завершения, а их память очищается, то возвращаемая ссыла будет указывать на несуществующий объект, как в следующем случае:

```c++
int& factorial(int n)
{
    int result = 1;
    for(int i = 1; i <=n; i++)
    {
        result *= i;
    }
    return result;
}
```

## [~] Организация консольного ввода и вывода данных

По умолчанию язык C++ не содержит встроенных средств для ввода с консоли и вывода на консоль, эти средства предоставляются библиотекой `iostream`. В ней определены два типа: `istream` и `ostream`. `istream` представляет поток ввода, а `ostream` - поток вывода.

Вобще сам темин "поток" в данном случае представляет последовательность символов, которая записывается на устройство ввода-вывода или считывается с него. И в данном случае под устройством ввода-вывода рассматривается консоль.

Для записи или вывода символов на консоль применяется объект `cout`, который представляет тип `ostream`. А для чтения с консоли используется объект `cin`

Для использования этих объектов в начало исходного файла необходимо подключить библиотеку `iostream`:

```c++
#include <iostream>
```

### Вывод на консоль

Для вывода на консоль применяется оператор `<<`. Этот оператор получает два операнда. Левый операнд представляет объект типа `ostream`, в данном случае объект `cout`. А правый операнд - значение, которое надо вывести на консоль.

Так как оператор `<<` возвращает левый операнд - `cout`, то с помощью цепочки операторов мы можем передать на консоль несколько значений. Например, определим простейшую программу вывода на консоль:

```c++
#include <iostream>
 
int main()
{   
    int age = 33;
    double weight = 81.23;
    std::cout << "Name: " << "Tom" << "\n";
    std::cout << "Age: " << age << std::endl;
    std::cout << "Weight: " << weight << std::endl;
    return 0;
}
```

Консольный вывод программы:

```custom
Name: Tom
Age: 33
Weight: 81.23
```

Оператору ``<<`` передаются различные значения - строки, значения переменных, которые выводятся на консоль.

Строки могут содержать управляющие последовательности, которые интерпретируются определенным образом. Например, последовательность `"\n"` интерпретируется как перевод на новую строку. Из других управляющих последовательностей также нередко употребляется `"\t"`, которая интерпретируется как табуляция.

Также цепочку операторов << можно завершать значением `std::endl`, которое вызывает перевод на новую строку и сброс буфера. При выводе в поток данные вначале помещаются в буфер. И сброс буфера гарантирует, что все переданные для вывода на консоль данные немедлено будут выведены на консоль.

### Ввод с консоли

Для считывания с консоли данных применяется оператор ввода `>>,` который принимает два операнда. Левый операнд представляет объект типа `istream` (в данном случае объект `cin`), с которого производится считывание, а правый операнд - объект, в который считываются данные.

Например, считаем данные с консоли:

```c++
#include <iostream>
 
int main()
{   
    int age;
    double weight;
    std::cout << "Input age: ";
    std::cin >> age;
    std::cout << "Input weight: ";
    std::cin >> weight;
    std::cout << "Your age: " << age << "\t your weight: " << weight << std::endl;
    return 0;
}
```

Здесь после приглашений к вводу программа ожидает ввода значений для переменных `age` и `weight`.

Пример работы программы:

```custom
Input age: 32
Input weight: 67.45
Your age: 32 your weight: 67.45
```

Стоит отметить, что так оператор ввода в первом случае будет добавлять данные в целочисленную переменную `age`, то он ожидает ввода числа. В случае с переменной `weight` оператор ввода ожидает дробное число, причем разделителем целой и дробной части должна быть точка. Поэтому мы не можем ввести любые значения, например, строки. В этом случае программа может выдать некорректный результат.

Оператор ввода >> возвращает левый операнд - объект `cin`, поэтому мы можем по цепочке считывать данные в различные переменные:

```c++
#include <iostream>
 
int main()
{   
    int age;
    double weight;
    std::cout << "Input age: ";
    std::cin >> age >> weight;
    std::cout << "Your age: " << age << "\t your weight: " << weight << std::endl;
    return 0;
}
```

Пример работы программы:

```custom
Input age: 32 67.45
Your age: 32 your weight: 67.45
```

После ввода одного из значений надо будет ввести пробел и затем вводить следующее значение.

### Примеры ввода и вывода

#### Ввод и вывод значения переменной

```c++
#include <iostream>
 
int main()
{ 
    int a;
    std::cin >> a;
    std::cout << a;
}
```

#### Ввод и вывод значений одномерного массива

```c++
#include <iostream>
 
int main()
{ 
    int a[10];
    
    /* Ввод в массив из консоли*/
    for(int i = 0; i < 10; i++)
        std::cin >> a[i];

    /* Вывод массива в консоль*/
    for(int i = 0; i < 10; i++)
        std::cout << a[i];
}
```

#### Ввод и вывод значений двумерные массива

```c++
#include <iostream>
 
int main()
{ 
    int a[10][3];
    
    /* Ввод в массив из консоли*/
    for(int i = 0; i < 10; i++)
        for(int j = 0; j < 3; j++)
            std::cin >> a[i][j];

    /* Вывод массива в консоль*/
    for(int i = 0; i < 10; i++)
        for(int j = 0; j < 3; j++)
            std::cout << a[i][j];
}
```

#### Ввод и вывод значений структуры

```c++
#include <iostream>

struct date {
    std::string text;
    int month;
    int year;
};

void main() 
{
    date object;
    std::cin >> object2.text >> object2.month >> object2.year; // Ввод значений структуры в одну строку.
    std::cout << object2.text << object2.month << object2.year; // Вывод значений структуры в одну строку.
}
```

## [~] Создание и работа с массивами, символьными строками, матрицами, структурами

### Работа с массивами

#### Одномерные массивы

Массив представляет набор однотипных данных. Формальное определение массива выглядит следующим образом:

```custom
тип_переменной название_массива [длина_массива];
```

После типа переменной идет название массива, а затем в квадратных скобках его размер. Например, определим массив из `4` чисел:

```c++
int numbers[4];
```

Данный массив имеет четыре числа, но все эти числа имеют неопределенное значение. Однако мы можем выполнить инициализацию и присвоить этим числам некоторые начальные значения через фигурные скобки:

```c++
int numbers[4] = {1,2,3,4};
```

Значения в фигурных скобках еще называют инициализаторами. Если инициализаторов меньше, чем элементов в массиве, то инициализаторы используются для первых элементов. Если в инициализаторов больше, чем элементов в массиве, то при компиляции возникнет ошибка:

```c++
int numbers[4] = {1, 2, 3, 4, 5, 6};
```

Здесь массив имеет размер `4`, однако ему передается 6 значений.

Если размер массива не указан явно, то он выводится из количества инициализаторов:

```c++
int numbers[] = {1, 2, 3, 4, 5, 6};
```

В данном случае в массиве есть `6` элементов.

Свои особенности имеет инициализация символьных массивов. Мы можем передать символьному массиву как набор инициализаторов, так и строку:

```c++
char s1[] = {'h', 'e', 'l', 'l', 'o'};
char s2[] = "world";
```

Причем во втором случае массив `s2` будет иметь не `5` элементов, а `6`, поскольку при инициализации строкой в символьный массив автоматически добавляется нулевой символ `'\0'`.

При этом не допускается присвоение одному массиву другого массива:

```c++
int nums1[] = {1,2,3,4,5};
int nums2[] = nums1;    // ошибка
nums2 = nums1;          // ошибка
```

После определения массива мы можем обратиться к его отдельным элементам по индексу. Индексы начинаются с нуля, поэтому для обращения к первому элементу необходимо использовать индекс `0`. Обратившись к элементу по индексу, мы можем получить его значение, либо изменить его:

```c++
#include <iostream>
 
int main()
{
    int numbers[4] = {1,2,3,4};
    int first_number = numbers[0];
    std::cout << first_number << std::endl; // 1
    numbers[0] = 34;                        // изменяем элемент
    std::cout << numbers[0] << std::endl; // 34
     
    return 0;
}
```

Число элементов массива также можно определять через константу:

```c++
const int n = 4;
int numbers[n] = {1,2,3,4};
```

#### Перебор массивов

Используя циклы, можно пробежаться по всему массиву и через индексы обратиться к его элементам:

```c+
#include <iostream>
 
int main()
{
    int numbers[4] = {1,2,3,4};
    int size = sizeof(numbers)/sizeof(numbers[0]);
    for(int i=0; i < size; i++)
        std::cout << numbers[i] << std::endl;
     
    return 0;
}
```

Чтобы пройтись по массиву в цикле, вначале надо найти длину массива. Для нахождения длины применяется оператор `sizeof`. По сути длина массива равна совокупной длине его элементов. Все элементы представляют один и тот же тип и занимают один и тот же размер в памяти. Поэтому с помощью выражения `sizeof(numbers)` находим длину всего массива в байтах, а с помощью выражения `sizeof(numbers[0])` - длину одного элемента в байтах. Разделив два значения, можно получить количество элементов в массиве. А далее с помощью цикла `for` перебираем все элементы, пока счетчик `i` не станет равным длине массива. В итоге на консоль будут выведены все элементы массива:

```custom
1
2
3
4
```

Но также есть и еще одна форма цикла `for`, которая предназначена специально для работа с коллекциями, в том числе с массивами. Эта форма имеет следующее формальное определение:

```custom
for(тип переменная : коллекция)
{
    инструкции;
}
```

Используем эту форму для перебора массива:

```c++
#include <iostream>
 
int main()
{
    int numbers[4] = {1,2,3,4};
    for(int number : numbers)
        std::cout << number << std::endl;
    return 0;
}
```

При переборе массива каждый перебираемый элемент будет помещаться в переменную `number`, значение которой в цикле выводится на консоль.

Если нам неизвестен тип объектов в массиве, то мы можем использовать спецификатор `auto` для определения типа:

```c++
for(auto number : numbers)
    std::cout << number << std::endl;
```

#### Многомерные массивы

Кроме одномерных массивов в C++ есть многомерные. Элементы таких массивов сами в свою очередь являются массивами, в которых также элементы могут быть массивами. Например, определим двухмерный массив чисел:

```c++
int numbers[3][2];
```

Такой массив состоит из трех элементов, при этом каждый элемент представляет массив из двух элементов. Инициализируем подобный массив:

```c++
int numbers[3][2] = { {1, 2}, {4, 5}, {7, 8} };
```

Вложенные фигурные скобки очерчивают элементы для каждого подмассива. Такой массив еще можно представить в виде таблицы:

```custom
1 2
4 5
7 8
```

Также при инициализации можно опускать фигурные скобки:

```c++
int numbers[3][2] = { 1, 2, 4, 5, 7, 8 };
```

Возможна также инициализация не всех элементов, а только некоторых:

```c++
int numbers[3][2] = { {1, 2}, {}, {7} };
```

И чтобы обратиться к элементам вложенного массива, потребуется два индекса:

```c++
int numbers[3][2] = { {1, 2}, {3, 4}, {5, 6} };
std::cout << numbers[1][0] << std::endl;    // 3
numbers[1][0] = 12;             // изменение элемента
std::cout << numbers[1][0] << std::endl;    // 12
```

Переберем двухмерный массив:

```c++
#include <iostream>
 
int main()
{
    const int rows = 3, columns = 2;
    int numbers[rows][columns] = { {1, 2}, {3, 4}, {5, 6} };
    for(int i=0; i < rows; i++)
    {
        for(int j=0; j < columns; j++)
        {
            std::cout << numbers[i] [j] << "\t";
        }
        std::cout << std::endl;
    }
    return 0;
}
```

Также для перебора элементов многомерного массива можно использовать другую форму цикла `for`:

```c++
#include <iostream>
 
int main()
{
    const int rows = 3, columns = 2;
    int numbers[rows][columns] = { {1, 2}, {3, 4}, {5, 6} };
     
    for(auto &subnumbers : numbers)
    {
        for(int number : subnumbers)
        {
            std::cout << number << "\t";
        }
        std::cout << std::endl;
    }
         
    return 0;
}
```

Для перебора массивов, которые входят в массив, применяются ссылки. То есть во внешнем цикле `for(auto &subnumbers : numbers)` - `&subnumbers` представляет ссылку на подмассив в массиве. Во внутреннем цикле `for(int number : subnumbers)` из каждого подмассива в `subnumbers` получаем отдельные его элементы в переменную `number` и выводим ее значение на консоль.

#### Динамические массивы

##### Одномерный динамический массив

Кроме отдельных динамических объектов в языке C++ мы можем использовать динамические массивы. Для выделения памяти под динамический массив также используется оператор `new`, после которого в квадратных скобках указывается, сколько массив будет содержать объектов:

```c++
int *numbers = new int[4]; // динамический массив из 4 чисел
```

Причем в этом случае оператор `new` также возвращает указатель на объект типа `int` - первый элемент в созданном массиве.

В данном случае определяется массив из четырех элементов типа `int`, но каждый из них имеет неопределенное значение. Однако мы также можем инициализировать массив значениями:

```c++
int *n1 = new int[4];   // каждый элемент имеет неопределенное значение
int *n2 = new int[4](); // каждый элемент имеет значение по умолчанию - 0
int *n3 = new int[4]{ 1, 2, 3, 4 }; // массив состоит из чисел 1, 2, 3, 4
```

В последнем случае при инициализации массива конкретными значениями следует учитывать, что если значений в фигурных скобках больше чем длина массива, то оператор new потерпит неудачу и не сможет создать массив. Если переданных значений, наоборот, меньше, то элементы, для которых не предоставлены значения, иницилизируются значением по умолчанию.

После создания динамического массива мы сможем с ним работать по полученному указателю, получать и изменять его элементы:

```c++
int n = 5;  // размер массива
int *p = new int[n]{ 1, 2, 3, 4, 5 };
for (int *q = p; q != p + n; q++)
{
    std::cout << *q << "\t";
}
```

Для удаления динамического массива и освобождения его памяти применяется специальная форма оператора `delete`:

```custom
delete [] указатель_на_динамический_массив;
```

Например:

```c++
#include <iostream>
 
int main()
{
    int n = 5;  // размер массива
    int *p = new int[n]{ 1, 2, 3, 4, 5 }; // массив состоит из чисел 1, 2, 3, 4
    for (int *q = p; q != p + n; q++)
    {
        std::cout << *q << "\t";
    }
 
    std::cout << std::endl;
 
    delete[] p;
 
    return 0;
}
```

##### Двумерный динамический массив

Создание двумерного массива:

```c++
// Создадим массив размером 20 элементов.
int **arr = new int* [10];
for(int i = 0; i < 2; i++)
    arr = new int[2];
```

Плюсом такого подхода является, что мы можем передовать `не-const` значения переменных:

```c++
// Создадим массив размером 20 элементов.
int n = 10;
int m = 2; 
int **arr = new int* [n];
for(int i = 0; i < 2; i++)
    arr = new int[m];
```

Заполнение элементов массива:

```c++
    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            cin >> arr[i][j];
```

Вывод массива:

```c++
    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            cout >> arr[i][j];
```

Удаление двухмерного массива:

```c++
    for(int i = 0; i < n; i++)
        delete[] arr[i]; // Удаляем одномерный массив на 2 элемента.
    delete[] arr; // Удаляем сам массив на 10 элементов.
```

### Работа с символными строками

#### [C++] std::strings (строки)

Для хранения строк в C++ применяется тип `string`. Для использования этого типа его необходимо подключить в код с помощью директивы `include`:

```c++
#include <string>
#include <iostream>
 
int main()
{
    std::string hello = "Hello World!";
    std::cout << hello << "\n";
    return 0;
}
```

Тип `string` определен в стандартной библиотеке и при его использовании надо указывать пространство имен `std`.

Либо можно использовать выражение `using`, чтобы не указывать префикс `std::`

```c++
using std::string;
```

В данном случае значение переменной `hello`, которая представляет тип `string`, выводится на консоль.

Для инициализации строк можно использовать различные способы:

```c++
#include <string>
#include <iostream>
 
int main()
{
    std::string s1;                 // пустая строка
    std::string s2 = "hello";       // hello
    std::string s3("welcome");      // welcome
    std::string s4(5, 'h');         // hhhhh
    std::string s5 = s2;            // hello
     
    std::cout << "Console:\n";
    std::cout << s1 << "\n";
    std::cout << s2 << "\n";
    std::cout << s3 << "\n";
    std::cout << s4 << "\n";
    std::cout << s5 << "\n";
    return 0;
}
```

Консольный вывод данной программы:

```custom
Console:

hello
welcome
hhhhh
hello
```

Если при определении переменной типа `string` мы не присваиваем ей никакого значения, то по умолчанию данная переменная содержит пустую строку:

```c++
std::string s1;
```

Также можно инициализировать переменную строчным литералом, который заключается в двойные кавычки:

```c++
std::string s2 = "hello";
```

В качестве альтернативы можно передавать строку в скобках после определения переменной:

```c++
std::string s3("welcome");
```

Если необходимо, чтобы строка содержала определенное количесто определеных символов, то можно указать в скобках количество символов и сам символ:

```c++
std::string s4(5, 'h');
```

И также можно передать переменной копию другой строки:

```c++
std::string s5 = s2;
```

##### Конкатенация строк

Над строками можно выполнять ряд операций. В частности, можно объединять строки с помощью стандартной операции сложения:

```c++
#include <iostream>
using std::cout;
using std::endl;
using std::string;
 
int main()
{   
    string s1 = "hello";
    string s2 = "world";
    string s3 = s1 + " " + s2; // hello world
    cout << s3 << endl;
    return 0;
}
```

##### Сравнение строк

К строкам можно применять операции сравнения. Оператор `==` возвращает `true`, если все символы обеих строк равны.

```c++
std::string s1 = "hello";
std::string s2 = "world";
 
bool result = s1 == s2;     // false
result = s1 == "Hello";     // false
result = s1 == "hello";     // true
```

При этом символы **должны совпадать в том числе по регистру**.

Операция `!=` возвращает `true`, если две строки не совпадают.

```c++
std::string s1 = "hello";
std::string s2 = "world";
 
bool result = s1 != s2;     // true
result = s1 != "Hello";     // true
result = s1 != "hello";     // false
```

Остальные базовые операции сравнения `<`, `<=`, `>`, `>=` сравнивают строки в зависимости от регистра и алфавитного порядка символов. Например, строка `"b"` условно больше строки `"a"`, так как символ `b` по алфавиту идет после символа `a`. А строка `"a"` больше строки `"A"`. Если первые символы строки равны, то сравниваются последующие символы:

```c++
std::string s1 = "Aport";
std::string s2 = "Apricot";

bool result = s1 > s2;       // false
```

В данном случае условие `s1 > s2` ложно, то есть `s2` больше чем `s1`, так как при равенстве первых двух символов (`"Ap"`) третий символ второй строки (`"o"`) стоит в алфавите до третьего символа второй строки (`"r"`), то есть `"o"` меньше чем `"r"`.

##### Размер строки

С помощью метода `size()` можно узнать размер строки, то есть из скольких символов она состоит:

```c++
std::string s1 = "hello";
std::cout << s1.size() << std::endl;    // 5
```

Если строка пустая, то она содержит `0` символов. В этом случае мы можем применить метод `empty()` - он возвращает `true`, если строка пустая:

```c++
std::string s1 = "";
if(s1.empty())
    std::cout << "String is empty" << std::endl;
```

##### Чтение строки с консоли

Для считывания введенной строки с консоли можно использовать объект `std::cin`:

```c++
#include <iostream>
#include <string>
 
int main()
{   
    std::string name;
    std::cout << "Input your name: ";
    std::cin >> name;
    std::cout << "Your name: " << name << std::endl;
    return 0;
}
```

Консольный вывод:

```custom
Input your name: Tom
Your name: Tom
```

Однако если при данном способе ввода строка будет содержать подстроки, разделенные пробелом, то `std::cin` будет использовать только первую подстроку:

```c++
Input your name: Tom Smith
Your name: Tom
```

Чтобы считать всю строку, применяется метод `getline()`:

```c++
#include <iostream>
#include <string>
 
int main()
{   
    std::string name;
    std::cout << "Input your name: ";
    getline(std::cin, name);
    std::cout << "Your name: " << name << std::endl;
    return 0;
}
```

Метод `getline` принимает два объекта - `std::cin` и `переменную`, в которую надо считать строку.

Консольный вывод:

```custom
Input your name: Tom Smith
Your name: Tom Smith
```

##### Получение и изменение символов строки

Подобно массиву мы можем обращаться с помощью индексов к отдельным символам строки, получать и изменять их:

```c++
std::string hello = "Hello";
char c = hello[1];      // e
hello[0]='M';
std::cout << hello << std::endl;    // Mello
```

#### [C] char[] и char* массивы как символьные строки

Массив символов, последний элемент которого представляет нулевой символ `'\0'`, может использоваться как строка:

```c++
#include <cstring>
#include <iostream>
  
int main()
{
    char letters[] = {'h', 'e', 'l', 'l', 'o', '\0'};
    std::cout << letters << std::endl;
     
    return 0;
}
```

Данный код выведет на консоль строку `"hello"`

Подобное определение массива строк будет также эквивалентно следующему:

```c++
char letters[] = "hello";
```

или

```c++
char letters[6] = "hello"; // 6 символ - это '\0'
```

##### Функции, для работы с Cи-строками

###### Размер

``strlen(имя_строки)`` - определяет длину указанной строки, без учёта `нуль-символа` (`'\0'`)

###### Копирование

``strcpy(s1,s2)`` - выполняет побайтное копирование символов из строки `s2` в строку `s1`

``strncpy(s1,s2, n)`` - выполняет побайтное копирование `n` символов из строки `s2` в строку `s1`. Возвращает значение `s1`

Рассмотрим пример:

```c++
#include <cstring>
#include <iostream>
using namespace std;
 
int main(int argc, char* argv[])
{
    char s2[27] = "Counter-Strike 1.6 forever";          // инициализация строки s2
    char s1[27];                                         // резервируем строку для функции strcpy()
    cout << "strcpy(s1,s2) = " << strcpy(s1,s2) << endl; // содержимое строки s2 скопировалось в строку s1, возвращается указатель на s1
    cout << "s1=             " << s1            << endl; // вывод содержимого строки s1
    char s3[7];                                          // резервируем строку для следующей функции
    cout << strncpy(s3, s2, 7) << endl;      // копируем 7 символов из строки s2 в строку s3
    system("pause");
    return 0;
}
```

В строках `9`, `10` создаём строковые массивы на `27` символов, словосочетание `"Counter-Strike 1.6 forever"` содержит `26` символов, последнее место в массиве займет `нуль-символ`. В строке 11 функция ```strcpy(s1,s2)``` копирует  значение строки  `s2` в строку `s1` и возвращает указатель на строку `s1`. Если строка `s1` будет меньше строки `s2`, то скопируется то количество символов, которое вместится в  строку `s2`. Строка `10` всего лишь показывает, что в строке `s1` содержится скопированное значение. В строке `14` функция `strncpy(s3, s2, sizeof(s3))` выполняет копирование `7` символов строки `s2` в строку `s3`

Консольный вывод:

```custom
strcpy(s1,s2) = Counter-Strike 1.6 forever
s1=             Counter-Strike 1.6 forever
CounterCounter-Strike 1.6 forever
```

###### Конкатенация

``strcat(s1,s2)`` - объединяет строку `s2` со строкой `s1`. Результат сохраняется в `s1`

``strncat(s1,s2,n)`` - объединяет `n` символов строки `s2` со строкой `s1`. Результат сохраняется в `s1`

Расмотрим пример, где используем функции `strcat()` и `strncat()`, для объединения строк, то есть для их конкатенации:

```c++
#include <cstring>
#include <iostream>

using namespace std;
 
int main(int argc, char* argv[])
{
    char s1[30] = "I am ";
    char s2[] = "programmer on the C++!!!!";
    cout << strcat(s1,s2) << endl;               // объединяем строки s1 и s2, результат сохраняется в строке s1
    char s3[23] = "I am a good ";
    cout << strncat(s3,s2,10) <<  "!!!" << endl; // объединяем 10 символов строки s2 со строкой s3
    system("pause");
    return 0;
}
```

В строке 11 функция `strcat(s1,s2)` объединяет строки `s1` и `s2`, результат сохраняется в строке `s1`. По этому при объявлении строки s1 её размер установлен на `30` символов. В строке `13` функция `strncat(s3,s2,10)` объединяет `10` символов из строки `s2`(как раз помещается слово `programmer`) со строкой `s3`, результат сохраняется в строке `s3`. И по этому размер строки `s3` также задан фиксировано.

Консольный вывод:

```custom
I am programmer on the C++!!!!
I am a good programmer!!!
```

###### Сравнение

``strcmp(s1,s2)`` - сравнивает строку `s1` со строкой `s2` и возвращает результат типа `int`: `0` – если строки эквивалентны, `>0` – если `s1 < s2`, `<0` — если `s1 > s2` *(С учётом регистра)*

``strncmp(s1,s2,n)`` - сравнивает `n` символов строки `s1` со строкой `s2` и возвращает результат типа `int`: `0` – если строки эквивалентны, `>0` – если `s1 < s2`,  `<0`  — если `s1 > s2` *(С учётом регистра)*

``stricmp(s1,s2)`` - сравнивает строку `s1` со строкой `s2` и возвращает результат типа `int`: `0` – если строки эквивалентны, `>0` – если `s1 < s2`,  `<0`  — если `s1 > s2` *(Без учёта регистра)*

``strnicmp(s1,s2,n)`` - сравнивает `n` символов строки `s1` со строкой `s2` и возвращает результат типа `int`: `0` – если строки эквивалентны, `>0` – если `s1 < s2`,  `<0`— если `s1 > s2` *(Без учёта регистра)*

Рассмотрим работу функции `strcmp()`, остальные функции используются аналогично, так что каждую рассматривать не будем:

```c++
#include "stdafx.h" // C
#include <cstring>  // C in C++ 
#include <iostream>
#include <iomanip>

using namespace std;

int main()
{
    char s1[] = "www.seperaokeq.su";
    char s2[] = "https://www.seperaokeq.su";
    cout << " s1 == s1 -> " << setw(2) << strcmp(s1,s1) << endl; // строка s1 = s1
    cout << " s1 <  s2 -> " << setw(2) << strcmp(s1,s2) << endl; // строка s1 < s2
    cout << " s2 >  s1 -> " << setw(2) << strcmp(s2,s1) << endl; // строка s2 > s1
    system("pause");
    return 0;
}
```

В строках `12`, `13`, `14` функция `strcmp()` выполняет сравнение строк, в различном порядке, таким образом были рассмотрены все возможные варианты работы данной функции. В первом случае строку `s1` сравнивали с самой собой соответственно и результат равен `0`. Во втором случае строка `s1` оказалась меньше строки `s2` поэтому результат равен `1`. В третьем случае строка `s1` по-прежнему меньше строки `s2`, но мы поменяли эти строки местами, таким образом, порядок параметров функции изменился и результат стал равен `-1`.

Консольный вывод:

```custom
 s1 == s1 ->  0
 s1 <  s2 ->  1
 s2 >  s1 -> -1
```

###### Обработка символов

``isalnum(c)`` - возвращает значение `true`, если с является буквой или цифрой, и `false` в других случаях

``isalpha(c)``- возвращает значение `true`, если с является буквой,  и `false` в других случаях

``isdigit(c)`` - возвращает значение `true`, если с является цифрой, и `false` в других случаях

``islower(c)`` - возвращает значение `true`, если с является буквой нижнего регистра, и `false` в других случаях

``isupper(c)`` - возвращает значение `true`, если с является буквой верхнего регистра, и `false` в других случаях

``isspace(c)`` - возвращает значение `true`, если с является пробелом, и `false` в других случаях

``toupper(c)`` - если символ `с`, является символом нижнего регистра, то функция возвращает преобразованный символ с в верхнем регистре, иначе символ возвращается без изменений.

###### Функции поиска

``strchr(s,c)`` - поиск первого вхождения символа `с` в строке `s`. В случае удачного поиска возвращает указатель на место первого вхождения символа `с`. Если символ не найден, то возвращается ноль.

``strcspn(s1,s2)`` - определяет длину начального сегмента строки `s1`, содержащего те символы, которые не входят в строку `s2`

``strspn(s1,s2)`` - возвращает длину начального сегмента строки `s1`, содержащего только те символы, которые входят в строку `s2`

``strprbk(s1,s2)`` - Возвращает указатель первого вхождения любого символа строки `s2` в строке `s1`

```strstr(s1, s2)``` - Функция ищет первое вхождение подстроки `s2` в строке `s1`. Возвращает указатель на первое вхождение строки `s2` в строку `s1`, или пустой указатель, если строка `s2` не является частью строки `s1`. В данном поиске `нуль-символ` не учитывается.

Функции из данной группы умеют различать, к какому типу знаков относятся те или иные символы, например буквы, цифры, специальные знаки, расмотрим пример:

```c++
#include "stdafx.h" // C
#include <cstring>  // C in C++
#include <iostream>

using namespace std;

int main()
{
    char symbol    = 'd'; // буква
    char digit     = '9'; // цифра
    char space     = ' '; // пробел
    char character = '#'; // знак
    // функция isalnum() проверяет является ли её аргумент буквой или цифрой
    cout << symbol    << " - it is digit or alpha?: "; isalnum(symbol)    ? cout << "true\n": cout << "false\n";
    // функция isalpha() проверяет является ли её аргумент буквой
    cout << symbol    << " - it is alpha?:          "; isalpha(symbol)    ? cout << "true\n": cout << "false\n";
    // функция isdigit() проверяет является ли её аргумент цифрой
    cout << digit     << " - it is digit?:          "; isdigit(digit)     ? cout << "true\n": cout << "false\n";
    // функция isspace() проверяет является ли её аргумент пробелом
    cout << space     << " - it is space?:          "; isspace(space)     ? cout << "true\n": cout << "false\n";
    // функция islower() проверяет является ли её аргумент буквой нижнего регистра
    cout << symbol    << " - it is lower alpha?:    "; islower(symbol)    ? cout << "true\n": cout << "false\n";
    // функция isupper() проверяет является ли её аргумент буквой верхнего регистра
    cout << symbol    << " - it is upper alpha?:    "; isupper(symbol) ? cout << "true\n": cout << "false\n";
    system("pause");
    return 0;
}
```

В данной программе по использованию функций вопросов возникать не должно. Функции сами по себе возвращают целочисленное значение, положительное – `true`, отрицательное или ноль – `false`. В формировании результата работы функций участвовал тернарный оператор, то есть выводилось сообщение `true` или `false` без всяких числовых значений.

Консольный вывод:

```custom
d - it is digit or alpha?: true
d - it is alpha?:          true
9 - it is digit?:          true
  - it is space?:          true
d - it is lower alpha?:    true
d - it is upper alpha?:    false
```

###### Функции преобразования

``atof(s1)`` - преобразует строку `s1` в тип `double/float`

``atoi(s1)`` - преобразует строку `s1` в тип `int`

``atol(s1)`` - преобразует строку `s1` в тип `long int`

Пример работы:

```c++
#include <iostream>
#include <cstdlib>
#include <cmath>
 
int main()
{
  double pi = 3.1415926535;                  // число ПИ
  char input [256];
  std::cout << "Введите угол в градусах: ";
  std::cin >> input;
 
  double agl = atof( input );                // преобразуем строку к типу данных double/float
 
  std::cout << "Синус угла "
            << agl << " градусов = "
            <<  sin(agl * pi / 180) << "n"; // вычисляем синус угла, переведённого в радианы
  return 0;
}
```

Консольный вывод:

```custom
Введите угол в градусах: 90
Синус угла 90 градусов = 1
```

###### Функции стандартной библиотеки ввода/вывода stdio

``getchar(с)``- считывает символ с со стандартного потока ввода, возвращает символ в формате `int`

``gets(s)`` - считывает поток символов со стандартного устройства ввода в строку `s` до тех пор, пока не будет нажата клавиша `ENTER`

###### Работа с локалью

```c++
char* setlocale (int category, const char* locale);
```

Устанавливает локаль для данного приложения. Если `locale` равно `NULL`, то `setlocale` может быть использована для получения текущей локали.

Локаль хранит информацию о языке и регионе, специфичную для работы функций ввода, вывода и трансформации строк. Во время работы приложения устанавливается локаль под названием `"C"`, которая совпадает с настройками локали по умолчанию. Эта локаль содержит минимум информации, и работа программы максимально предсказуема. Локаль `"C"` также называется `""`. Константы `category` определяют, на что воздействует изменение локали.

 |  Имя | На что влияет |
 | - | - |
 | LC_ALL | На всю локаль  |
 | LC_COLLATE | На поведение strcoll и strxfrm.  |
 | LC_CTYPE | На поведение функций, работающих с символами.  |
 | LC_NUMERIC | На десятичный разделитель в числах.  |
 | LC_TIME | На поведение strftime.  |

Строка locale содержит имя локали, например `"EN_US"` / `"RU"` / `"RU_RU"` или `"cp1251"`

### Работа с матрицами

Матрица — это двумерный массив, каждый элемент которого имеет два индекса: номер строки и номер столбца, поэтому для работы с элементами матрицы необходимо использовать два цикла. Если значениями параметра первого цикла будут номера строк матрицы, то значениями параметрами второго — столбцы (или наоборот). Обработка матрицы заключается в том, что вначале поочередно рассматриваются элементы первой строки (столбца), затем второй и т.д. до последней.

#### Создание матрицы

См. создание двумерных [статических](#многомерные-массивы) или [динамических](#двумерный-динамический-массив) массивов.

#### Ввод и вывод матрицы

См. [ввод и вывод двумерных](#ввод-и-вывод-значений-двумерные-массива) массивов.

#### Удаление матрицы

См. удаление двумерных массивов.

#### Операции с матрицами

##### Сложение матриц

```c++
#include <iostream>

using namespace std;

int main()
{
    int i, j, N = 3, M = 3,     // N - число столбцев. М - число рядков.
    int a[3][3], b[3][3], c[3][3]; 
    cout << "\nInput matrix A \n";
    for (i = 0; i < N; i++)
    {
        for (j = 0; j < M; j++)
            cin >> a[i][j];
    }
    cout << "Input matrix B " << endl;
    for (i = 0; i < N; i++)
    {
        for (j = 0; j < M; j++)
            cin >> b[i][j];
    }
    for (i = 0; i < N; i++)
    {
        for (j = 0; j < M; j++)
            c[i][j] = a[i][j] + b[i][j];
    }
    cout << " \t Summation Matrix \n";
    for (i = 0; i < N; i++)
    {
        for (j = 0; j < M; j++)
            cout << "\t" << c[i][j] << "\t";
        cout << endl;
    }
    return 0;
}
```

##### Вычитание матриц

```c++
#include <iostream>

using namespace std;

int main()
{
    int i, j, N = 3, M = 3,     // N - число столбцев. М - число рядков.
    int a[3][3], b[3][3], c[3][3]; 
    cout << "\nInput matrix A \n";
    for (i = 0; i < N; i++)
    {
        for (j = 0; j < M; j++)
            cin >> a[i][j];
    }
    cout << "Input matrix B " << endl;
    for (i = 0; i < N; i++)
    {
        for (j = 0; j < M; j++)
            cin >> b[i][j];
    }
    for (i = 0; i < N; i++)
    {
        for (j = 0; j < M; j++)
            c[i][j] = a[i][j] - b[i][j];
    }
    cout << " \t Subtraction Matrix \n";
    for (i = 0; i < N; i++)
    {
        for (j = 0; j < M; j++)
            cout << "\t" << c[i][j] << "\t";
        cout << endl;
    }
    return 0;
}
```

##### Умножение матрицы на k

```c++
#include <iostream>

using namespace std;

int main()
{
    int i, j, N = 3, M = 3,     // N - число столбцев. М - число рядков.
    int a[3][3]; 
    int k;
    cout << "\nInput matrix A \n";
    for (i = 0; i < N; i++)
    {
        for (j = 0; j < M; j++)
            cin >> a[i][j];
    }
    cout << "Input k: " << endl;
    cin >> k;
    for (i = 0; i < N; i++)
    {
        for (j = 0; j < M; j++)
            a[i][j] =  a[i][j] * k;
    }
    for (i = 0; i < N; i++)
    {
        for (j = 0; j < M; j++)
            cout << " " << a[i][j] << " ";
        cout << endl;
    }
    return 0;
}
```

##### Транспортирование матрицы

В данном примере мы транспортируем матрицу 3 на 3:

```c++
#include <iostream>
using namespace std;
int main(){
    int A[3][3], B[3][3], j, i; 
    for (i = 0; i < 3; i++){
        for (j = 0; j < 3; j++)
            cin >> A[i][j];
    }
    for (i = 0; i < 3; i++){
        for (j = 0; j < 3; j++)
            B[i][j] = A[j][i];
    }
    for (i = 0; i < 3; i++){
        for (j = 0; j < 3; j++)
            cout << B[i][j];
        cout << endl;
    }
    system("pause");
    return 0;
}
```

#### Примеры задач с матрицами

##### Найти сумму элементов матрицы, лежащих выше главной диагонали

![image_matrix_1](https://media.discordapp.net/attachments/866109504705265695/930219171650891816/unknown.png)

Алгоритм решения данной задачи можно построить следующим образом: обнулить ячейку для накапливания суммы (переменная S). Затем с помощью двух циклов просмотреть каждый элемент матрицы, суммировать элементы при условии, что элемент находиться выше главной диагонали. Код решения задачи:

```c++
#include "stdafx.h"
#include <iostream>
using namespace std;
int main()
{
    setlocale (LC_ALL, "RUS");
    int S, i, j, N, M, a[20][20];
    cout << "N="; 
    cin >> N;
    cout << "M="; 
    cin >> M;
    cout << "Введите матрицу А \n";
    for (i = 0; i < N; i++)
        for (j = 0; j < M; j++)
            cin >> a[i][j];
    for (S = i = 0; i < N; i++)
        for (j = 0; j < M; j++)
        //если элемент лежит выше главной диагонали, то наращиваем сумму
        if (j > i) 
            S += a[i][j];
    cout << "S=" << S << endl;
    system("pause");
    return 0;
}
```

##### Проверить, является ли заданная квадратная матрица единичной

```c++
#include <iostream>
using namespace std;
int main()
{
    int pr,i,j,N,a[20][20];
    cout << "N=";
    cin >> N;
    cout << "Input Matrix A" << endl;
    for(i = 0;i < N; i++)
        for(j = 0;j < N; j++)
            cin >> a[i][j];

    //Предполаем, что матрица — единичная, pr=1.
    for(pr = 1,i = 0;i < N; i++)
        for(j = 0;j < N; j++)
            //Если элемент лежит на главной диагонали и это не 1,
            //или элемент вне главной диагонали и это не 0, то
            // матрица не единичная, pr=0.
            if (((i==j) && (a[i][j]!=1)) || ((i!=j) && (a[i][j]!=0)))
            { 
                pr=0; 
                break; 
            }

    if (pr) 
        cout << "Единичная матрица\n";
    else 
        cout << "Матрица не является единичной\n";
}
```

### Работа со структурами

Структура в языке программирования С/C++ представляет собой производный тип данных, который объединяет в единое целое множество компонентов. При этом в отличие от массива эти компоненты могут представлять различные типы данных.

Для определения структуры применяется ключевое слово `struct`, а сам формат определения выглядит следующим образом:

```custom
struct имя_структуры
{
    компоненты_структуры
};
```

`Имя_структуры` представляет произвольный идентификатор, к которому применяются те же правила, что и при наименовании переменных.

После имени структуры в фигурных скобках помещаются `Компоненты_структуры`, которые представляют набор описаний объектов, которые составляют структуру.

Следует отметить, что в отличие от функции при определении структуры после закрывающей фигурной скобки идет точка с запятой.

Например, определим простейшую структуру:

```c++
struct person
{
    int age;
    char* name;
};
```

Здесь определена структура `person`, которая имеет два элемента: `age` (представляет тип `int`) и `name` (представляет указатель на тип `char`).

Все элементы структуры объявляются как обычные переменные. Но в отличие от переменных при определении элементов структуры для них не выделяется память, и их нельзя инициализировать. По сути мы просто определяем новый тип данных.

После определения структуры мы можем ее использовать. Для начала мы можем определить объект структуры - по сути обычную переменную, которая будет представлять выше созданный тип:

```c++
struct person tom;
```

Здесь определена переменная `tom`, которая представляет структуру `person`. И при каждом определении переменной типа структуры ей будет выделяться память, необходимая для хранения ее элементов.

При определении переменной структуры ее можно сразу инициализировать, присвоив какое-нибудь значение:

```c++
struct person tom = {23, "Tom"};
```

Инициализация структур аналогична инициализации массивов: в фигурных скобках передаются значения для элементов структуры по порядку. Так как в структуре person первым определено свойство, которое представляет тип `int` - число, то в фигурных скобках вначале идет число. И так далее для всех элементов структуры по порядку.

Также после создания переменной структуры можно обращаться к ее элементам - получать их значения или, наоборот, присваивать им новые значения. Для обращения к элементам структуры используется операция "точка":

```custom
имя_переменной_структуры.имя_элемента
```

Теперь объединим все вместе в рамках программы:

```c++
#include <iostream>
 
struct person
{
    int age;
    char* name;
};
 
int main(void)
{
    struct person tom = {23, "Tom"};
    cout << "Age: " << tom.age << "Name:" << tom.name;
    return 0;
}
```

Консольный вывод программы:

```custom
Age: 23  Name: Tom
```

С элементами структуры можно производить все те же операции, что и с переменными тех же типов. Например, добавим ввод с консоли:

```c++
#include <iostream>
 
struct person
{
    int age;
    char name[20];
};
int main(void)
{
    struct person tom = {23, "Tom"};
    cout << "Enter name: ";
    cin >> tom.name;
    cout <<"Enter age: ";
    cin >> tom.age;
    cout << "Age: " << tom.age << "Name:" << tom.name;
    return 0;
}
```

Консольный вывод программы:

```custom
Enter name: Eugene
Enter age: 33
Name: Eugene Age: 33
```

Мы можем одновременно совмещать определение типа структуры и ее переменных:

```c++
#include <iostream>
 
struct person
{
    int age;
    char* name;
} tom, bob, alice;
 
int main(void)
{
    tom.name ="Tom";
    tom.age = 23;
    bob.name = "Bob";
    bob.age = 15;
    alice.name = "Alice";
    alice.age=25;
    cout << "Age: " << tom.age << "Name:" << tom.name;
    return 0;
}
```

После определения структуры, но до точки запятой мы можем через запятую перечислить набор переменных. А затем присвоить их элементам значения.

При подобном определении мы можем даже не указывать имя структуры:

```c++
struct
{
    int age;
    char* name;
} tom, bob, alice;
```

В этом случае компилятор все равно будет знать, что переменные `tom`, `bob` и `alice` представляют структуры с двумя элементами `name` и `age`. И соответственно мы также с этими переменными сможем работать. Другое дело, что мы не сможем задать новые переменные этой структуры в других местах программы.

#### Использование typedef

Еще один способ определения структуры представляет ключевое слово typedef:

```c++
#include <stdio.h>
 
typedef struct
{
    int age;
    char * name;
} person;
 
int main(void)
{
    person tom = {23, "Tom"};
    cout << "Age: " << tom.age << "Name:" << tom.name;
    return 0;
}
```

В конце определения структуры после закрывающей фигурной скобки идет ее обозначение - в данном случае `person`. В дальнейшем мы можем использовать это обозначение для создания переменной структуры. При этом в отличие от примеров выше здесь не надо при определении переменной не надо использовать слово `struct`.

#### Директива define

Еще один способ определить структуру представляет применение препроцессорной директивы `#define`:

```c++
#include <iostream>
 
#define PERSON struct {int age; char name[20];}
 
int main(void)
{
    PERSON tom = {23, "Tom"};
    cout << "Age: " << tom.age << "Name:" << tom.name;
    return 0;
}
```

В данном случае директива `define` определяет константу `PERSON`, вместо которой при обработке исходного кода препроцессором будет вставляться код структуры `struct {int age; char name[20];}`

## [~] Работа с файлами

# Создание функций

Функция определяет действия, которые выполняет программа. Функции позволяют выделить набор инструкций и придать ему имя. А затем многократно по присвоенному имени вызывать в различных частях программы. По сути функция - это именованный блок кода.

Формальное определение функции выглядит следующим образом:

```custom
тип имя_функции(параметры)
{
    инструкции
}
```

Первая строка представляет заголовок функции. Вначале указывается возвращаемый тип функции. Если функция не возвращает никакого значения, то используется тип `void`.

Затем идет имя функции, которое представляет произвольный идентификатор. К именованию функции применяются те же правила, что и к именованию переменных.

После имени функции в скобках идет перечисление параметров. Функция может не иметь параметров, в этом случае указываются пустые скобки.

После заголовка функции в фигурных скобках идет тело функции, которое содержит выполняемые инструкции.

Для возвращения результата функция применяет оператор `return`. Если функция имеет в качестве возвращаемого типа любой тип, кроме `void`, то она должна обязательно с помощью оператора `return` возвращать какое-либо значение.

Например, определение функции `main`, которая должна быть в любой программе на языке C++ и с которой начинается ее выполнение:

```c++
int main()
{
    return 0;
}
```

Возвращаемым типом функции является тип `int`, поэтому функция должна использовать оператор `return` и возвращать какое-либо значение, которое соответствует типу `int`. Возвращаемое значение ставится после оператора `return`.

Но если функция имеет тип `void`, то ей не надо ничего возвращать. Например, мы могли бы определить следующую функцию:

```c++
void hello()
{
    std::cout << "hello\n";
}
```

## [~] Выполнение функции

Для выполнения функции ее необходимо вызвать. Вызов функции осуществляется в форме:

```custom
имя_функции(аргументы);
```

После имени функции указываются скобки, в которых перечисляются аргументы - значения для параметров функции.

Например, определим и выполним простейшую функцию:

```c++
#include <iostream>
 
void hello()
{
    std::cout << "hello\n";
}
 
int main()
{
    hello();
    hello();
    return 0;
}
```

Здесь определена функция hello, которая вызывается в функции main два раза. В этом и заключается преимущество функций: мы можем вынести некоторые общие действия в отдельную функцию и затем вызывать многократно в различных местах программы. В итоге программа два раза выведет строку "hello".

Консольный вывод:

```custom
hello
hello
```

## [~] Объявление функции

При использовании функций стоит учитывать, что компилятор должен знать о функции до ее вызова. Поэтому вызов функции должен происходить после ее определения, как в случае выше. В некоторых языках это не имеет значение, но в языке C++ это играет большую роль. И если, к примеру, мы сначала вызовем, а потом определим функцию, то мы получим ошибку на этапе компиляции, как в следующем случае:

```c++
#include <iostream>
 
int main()
{
    hello(); // Error
    hello(); // Error
    return 0;
}
 
void hello()
{
    std::cout << "hello\n";
}
```

В этом случае перед вызовом функции надо ее дополнительно объявить. Объявление функции еще называют прототипом. Формальное объявление выглядит следующим образом:

```custom
тип имя_функции(параметры);
```

Фактически это заголовок функции. То есть для функции `hello` объявление будет выглядеть следующим образом:

```c++
void hello();
```

Используем объявление функции:

```c++
#include <iostream>
 
void hello();
 
int main()
{
    hello();
    hello();
    return 0;
}
 
void hello()
{
    std::cout << "hello\n";
}
```

В данном случае несмотря на то, что определение функции идет после ее вызова, но так как функция уже объявлена до ее вызова, то компилятор уже будет знать о функции `hello`, и никаких проблем в работе программы не возникнет.

## [~] Оформление функций

### Параметры функций

Через параметры в функцию можно передать различеые значения. Параметры перечисляются в скобках после имени функции имеют следующее определение:

```custom
тип название_параметра
```

Например, определим программу обменного пункта:

```c++
#include <iostream>
 
void exchange(double, double);
 
int main()
{
    double rate = 58;
    double sum = 5000;
    exchange(rate, sum);
    exchange(60, 5000);
    return 0;
}
 
void exchange(double currate, double sum)
{
    double result = sum / currate;
    std::cout <<  "Rate: " << currate << "\tSum: " << sum 
            << "\tResult: " << result << std::endl;
}
```

При запуске программы мы получим следующий консольный вывод:

```custom
Rate: 58 Sum: 5000 Result: 86.2069
Rate: 60 Sum: 5000 Result: 83.3333
```

Функция `exchange` принимает два параметра типа `double`, которые называются `currate` (текущий курс) и `sum` (сумма, которую надо обменять).

При вызове функции `exchange` для этих параметров необходимо передать значения. Значения, передаваемые параметрам функции при ее вызове, называются аргументами. В данном случае в качестве аргументов передаются обычные числа. При этом аргументы передаются по позиции, то есть первый аргумент передается первому параметру, второй аргумент - второму параметру и так далее. При этом аргументы должны соответствовать параметрам по типу или допускать неявно преобразование в тип параметра.

Рассмотрим еще один пример с функциями:

```c++
#include <iostream>
#include <string>
 
void square(int);
void display(std::string, int);
 
int main()
{
    display("Tom", 33);
    square(4.56);
 
    return 0;
}
void square(int x)
{
    std::cout << "Square of " << x << " is equal to " << x * x << std::endl;
}
 
void display(std::string name, int age)
{
    std::cout << "Name: " << name << "\tAge: " << age << std::endl;
}
```

Функция `display` принимает параметры типов `string` и `int`. При вызове этой функции в нее вначале передается строка (`"Tom"`), так как параметр типа string идет первым, а потом число (`33`), так как параметр типа `int` идет вторым: `display("Tom", 33)`

Функция `square` принимает число и выводит на консоль его квадрат. Параметр функции представляет тип `int`, однако при ее вызове ей передается число с плавающей точкой, то есть значение типа `double`. Поэтому производится преобразование от типа `double` к типу `int`, дробная часть отбрасывается, и в итоге функция получает число `4`.

#### Аргументы по умолчанию

Функция может принимать аргументы по умолчанию, то есть некоторые значения, которые функция использует, если при вызове для параметров явным образом не передается значение:

```c++
#include <iostream>
 
void multiply(int n, int m = 3)
{
    int result = n * m;
    std::cout << "n * m = " << result << std::endl;
}
int main()
{
    multiply(4, 5);
    multiply(4);
    return 0;
}
```

Для установки значения по умолчанию параметру присваивается это значение `int m = 3`. И если для второго параметра не будет передано значение, то он будет использовать значение по умолчанию.

Консольный вывод программы:

```custom
n * m = 20
n * m = 12
```

При объявлении прототипа подобной функции он тоже может содержать значение по умолчанию для параметра. И в этом случае мы можем не определять в функции значение по умолчанию для параметра - оно будет браться из прототипа:

```c++
#include <iostream>
 
void multiply(int n, int m = 3);
 
int main()
{
    multiply(4, 5);
    multiply(4);
    return 0;
}
 
void multiply(int n, int m)
{
    int result = n * m;
    std::cout << "n * m = " << result << std::endl;
}
```

### Возвращение результата

См. оператор [return](#оператор-return)

## [~] Передача параметров в функцию: по значению, по указателю, по ссылке

### Передача параметров по значению

При передаче аргументов по значению внешний объект, который передается в качестве аргумента в функцию, не может быть изменен в этой функции. В функцию передается само значение этого объекта.

Например:

```c++
#include <iostream>
 
void square(int, int);
 
int main()
{
    int a = 4;
    int b = 5;
    std::cout << "Before square: a = " << a << "\tb=" << b << std::endl;
    square(a, b);
    std::cout << "After square: a = " << a << "\tb=" << b << std::endl;
 
    return 0;
}
void square(int a, int b)
{
    a = a * a;
    b = b * b;
    std::cout << "In square: a = " << a << "\tb=" << b << std::endl;
}
```

Функция `square` принимает два числа и возводит их в квадрат. В функции `main` перед и после выполнения функции `square` происходит вывод на консоль значений переменных `a` и `b`, которые передаются в `square` в качестве аргументов.

И при выполнении мы увидим, что изменения аргументов в функции `square` действуют только в рамках этой функции. Вне ее значения переменных `a` и `b` остаются неизменными:

```custom
Before square: a = 4 	b = 5
In square: a = 16		b = 25
After square: a = 4 	b = 5
```

Почему так происходит? При компиляции функции для ее параметров выделяются отдельные участки памяти. При вызове функции вычисляются значения аргументов, которые передаются на место параметров. И затем значения аргументов заносятся в эти участки памяти. То есть функция манипулирует копиями значений объектов, а не самими объектами.

### Передача параметров по ссылке

При передаче параметров по ссылке передается ссылка на объект, через которую мы можем манипулировать самим объектов, а не просто его значением. Так, перепишем предыдущий пример, используя передачу по ссылке:

```c++
#include <iostream>
 
void square(int&, int&);
 
int main()
{
    int a = 4;
    int b = 5;
    std::cout << "Before square: a = " << a << "\tb=" << b << std::endl;
    square(a, b);
    std::cout << "After square: a = " << a << "\tb=" << b << std::endl;
 
    return 0;
}
void square(int &a, int &b)
{
    a = a * a;
    b = b * b;
    std::cout << "In square: a = " << a << "\tb=" << b << std::endl;
}
```

Теперь параметры `a` и `b` передаются по ссылке. Ссылочный параметр связывается непосредственно с объектом, поэтому через ссылку можно менять сам объект.

И если мы скомпилируем и запустим программу, то результат будет иным:

```custom
Before square: a = 4 	b = 5
In square: a = 16		b = 25
After square: a = 16 	b = 25
```

Передача по ссылке позволяет возвратить из функции сразу несколько значений. Также передача параметров по ссылке является более эффективной при передаче очень больших объектов. Поскольку в этом случае не происходит копирования значений, а функция использует сам объект, а не его значение.

От передачи аргументов по ссылке следует отличать передачу ссылок в качестве аргументов:

```c++
#include <iostream>
 
void square(int, int);
 
int main()
{
    int a = 4;
    int b = 5;
    int &aRef = a;
    int &bRef = b;
    std::cout << "Before square: a = " << a << "\tb=" << b << std::endl;
    square(aRef, bRef);
    std::cout << "After square: a = " << a << "\tb=" << b << std::endl;
 
    return 0;
}
void square(int a, int b)
{
    a = a * a;
    b = b * b;
    std::cout << "In square: a = " << a << "\tb=" << b << std::endl;
}
```

Если функция принимает аргументы по значению, то изменение параметров внутри функции также никак не скажется на внешних объектах, даже если при вызове функции в нее передаются ссылки на объекты.

```custom
Before square: a = 4 	b = 5
In square: a = 16		b = 25
After square: a = 4 	b = 5
```

Передача параметров по значению больше подходит для передачи в функцию небольших объектов, значения которых копируются в определенные участки памяти, которые потом использует функция.

Передача параметров по ссылке больше подходит для передачи в функцию больших объектов, в этом случае не нужно копировать все содержимое объекта в участок памяти, за счет чего увеличивается производительность программы.

### Передача параметров по указателю

Параметры функции в C++ могут представлять указатели. Указатели передаются в функцию по значению, то есть функция получает копию указателя. В то же время копия указателя будет в качестве значения иметь тот же адрес, что оригинальный указатель. Поэтому используя в качестве параметров указатели, мы можем получить доступ к значению аргумента и изменить его.

Например, пусть у нас будет простейшая функция, которая увеличивает число на единицу:

```c++
#include <iostream>
 
void increment(int);
 
int main()
{
    int n = 10;
    increment(n);
    std::cout << "main function: " <<  x << std::endl;
    return 0;
}
void increment(int x)
{
    x++;
    std::cout << "increment function: " <<  x << std::endl;
}
```

Здесь переменная `n` передается в качестве аргумента для параметра `x`. Передача происходит по значению, поэтому любое изменение параметра `x` в функции `increment` никак не скажется на значении переменной n.

Что мы можем увидеть, запустим программу:

```custom
increment function: 11
main function: 10
```

Теперь изменим функцию `increment`, использовав в качестве параметра указатель:

```c++
#include <iostream>
 
void increment(int*);
 
int main()
{
    int n = 10;
    increment(&n);
    std::cout << "main function: " <<  n << std::endl;
    return 0;
}
void increment(int *x)
{
    (*x)++;
    std::cout << "increment function: " <<  *x << std::endl;
}
```

Для изменения значения параметра применяется операция разыменования с последующим инкрементом: `(*x)++`. Это изменяет значение, которое находится по адресу, хранимому в указателе `x`.

Поскольку теперь функция в качестве параметра принимает указатель, то при ее вызове необходимо передать адрес переменной: `increment(&n);`.

В итоге изменение параметра `x` также повлияет на переменную `n`:

```custom
increment function: 11
main function: 11
```

В то же время поскольку аргумент передается в функцию по значению, то есть функция получает копию адреса, то если внутри функции будет изменен адрес указателя, то это не затронет внешний указатель, который передается в качестве аргумента:

```c++
#include <iostream>
 
void increment(int*);
 
int main()
{
    int n = 10;
    int *ptr = &n;
    increment(ptr);
    std::cout << "main function: " <<  n << std::endl;
    return 0;
}
void increment(int *x)
{
    int z = 6;
    x = &z;     // переустанавливаем адрес указателя x
    std::cout << "increment function: " <<  *x << std::endl;
}
```

В функцию `increment` передается указатель `ptr`. При вызове функция получает копию этого указателя в виде парамета `x`. В функции изменяется адрес указателя `x`. Но это никак не затронет указатель `ptr`, так как он предствляет другую копию. В итоге поле переустановки адреса указатели `x` и `ptr` будут хранить разные адреса.

Результат работы программы:

```custom
increment function: 6
main function: 10
```

## [~] Перегрузка функций

Перегрузка функций — это возможность определять несколько функций с одним и тем же именем, но с разными параметрами. Например:

```c++
int subtract(int a, int b)
{
    return a - b;
}
```

Здесь мы выполняем операцию вычитания с целыми числами. Однако, что, если нам нужно использовать числа типа с плавающей запятой? Эта функция совсем не подходит, так как любые параметры типа `double` будут конвертироваться в тип `int`, в результате чего будет теряться дробная часть значений.

Одним из способов решения этой проблемы является определение двух функций с разными именами и параметрами:

```c++
int subtractInteger(int a, int b)
{
    return a - b;
}
 
double subtractDouble(double a, double b)
{
    return a - b;
}
```

Но есть и лучшее решение — перегрузка функции. Мы можем просто объявить еще одну функцию `subtract()`, которая принимает параметры типа `double`:

```c++
double subtract(double a, double b)
{
    return a - b;
}
```

Теперь у нас есть две версии функции `subtract()`:

```c++
int subtract(int a, int b); // целочисленная версия
double subtract(double a, double b); // версия типа с плавающей запятой
```

### Типы возврата в перегрузке функций

Обратите внимание, **тип возврата функции НЕ учитывается** при перегрузке функции. Предположим, что вы хотите написать функцию, которая возвращает рандомное число, но вам нужна одна версия, которая возвращает значение типа `int`, и вторая — которая возвращает значение типа `double`. У вас может возникнуть соблазн сделать следующее:

```c++
int getRandomValue();
double getRandomValue();
```

Компилятор выдаст ошибку. Эти две функции имеют одинаковые параметры (точнее, они отсутствуют), и, следовательно, второй вызов функции `getRandomValue()` будет рассматриваться как ошибочное переопределение первого вызова. Имена функций нужно будет изменить.

## [~] Рекрусивные функции

Рекурсивные функции - это функции, которые вызывают сами себя. Например, определим вычисление факториала в виде рекурсивной функции:

```c++
#include <iostream>
 
int factorial(int);
 
int main()
{
    int n = 5;
    int result = factorial(n);
    std::cout << "Factorial of " << n << " is equal to " << result << std::endl;
    return 0;
}
 
int factorial(int n)
{
    if(n>1)
        return n * factorial(n-1);
    return 1;
}
```

В функции `factorial` задано условие, что если число `n` больше `1`, то это число умножается на результат этой же функции, в которую в качестве параметра передается число `n-1`. То есть происходит рекурсивный спуск. И так далее, пока не дойдем того момента, когда значение параметра не будет равно `1`. В этом случае функция возвратит `1`.

Рекурсивная функция обязательно должна иметь некоторый базовый вариант, который использует оператор `return` и к которому сходится выполнение остальных вызовов этой функции. В случае с факториалом базовый вариант представлен ситуацией, при которой `n = 1`. В этом случае сработает инструкция `return 1`;.

Например, при вызове `factorial(5)` получится следующая цепь вызовов:

```custom
5 * factorial(4)

5 * 4 * factorial(3)

5 * 4 * 3 * factorial(2)

5 * 4 * 3 * 2 * factorial(1)

5 * 4 * 3 * 2 * 1
```

Другим распространенным показательным примером рекурсивной функции служит функция, вычисляющая числа Фиббоначчи. n-й член последовательности чисел Фибоначчи определяется по формуле: `f(n)=f(n-1) + f(n-2)`, причем `f(0)=0`, а `f(1)=1`. Значения `f(0)=0` и `f(1)=1`, таким образом, определяют базовые варианты для данной функции:

```c++
#include <iostream>
 
int fibonachi(int);
 
int main()
{
    int n;
    for(int i = 0; i < 10; i++)
    {
        n = fibonachi(i);
        std::cout << n << "\t";
    }
    std::cout << std::endl;
    return 0;
}
int fibonachi(int n)
{
    if (n == 0)
        return 0;
    if (n == 1)
        return 1;
    return fibonachi(n - 1) + fibonachi(n - 2);
}
```

Результат работы программы - вывод 10 чисел из последовательности Фиббоначчи на консоль:

```custom
0,   1,   1,   2,   3,   5,   8,   13,   21,   34
```

## [~] Библиотека функций для работы с символьными строками

Cм. [функции для Си-подобных строк](#функции-для-работы-с-cи-строками)

# Базовые алгоритмы

## [~] Алгоритмы обработки числовых данных

### Вычисление ряда

Задача. Дана сумма ряда от 1 до n 1/x^i. Без использования `pow`.

![image_rad](https://i.stack.imgur.com/2B1dk.png)

`pow` действительно не нужен - ведь `i+1-й член` получается делением i-го на `x` - так что каждый очередной член вычисляется "на ходу".

```c++
#include <iostream>

using namespace std;

int main()
{
    int N;
    double sum = 0, x, term;
    cout << "Введите N: ";
    cin >> N;
    cout << "Введите x: ";
    cin >> x;
    term = 1;
    for(int i = 0; i < N; ++i)
    {
        term /= x;
        sum += term;
    }

    cout << sum << endl;

}
```

### Проверка на простоту

```c++
int main()
{
    int n;
    // ввести n c клавиатуры
    for (i = 2; i <= sqrt(n); i++) 
    {
        if (n % i == 0) {
            // вывести, что n не простое, так как делится на i
            return 0;
        }
    }
    //вывести что n простое.
    return 0;
}
```

### Определение делителей

```c++
#include <iostream>
using namespace std;
 
int main()
{
    int n, i;
    cout << "Введите число N: " << endl;
    cin >> n;
    for (i = n; i > 0; i--) {
        if (n%i == 0) {
        cout << "Делитель: " << i << endl;
        }
    }
    return 0;
}
```


## [~] Алгоритмы обработки последовательностей

## [~] Алгоритмы работы с символьными строками

### Поиск слова максимальной длины

Пример: ``aaaa bbbbb ccccc dddd \0``

### Поиск количества вхождений заданного слова в строку

Исходный код первой и второй задачи:

```c++
void GetMaxWord(char *str, char *w);
int GetCountWord(char *str, char *w);

int main()
{
    char str[100], w[20];
    cin.getline(str, 100);
    /*GetMaxWord(str,w);
    cout<<w<<endl;
    */
    cin >> w;
    cout << GetCountWord(str, w) << endl;
    return 0;
}

void GetMaxWord(char *str, char *w)
{
    /*
    int i=0;
    while(str[i]!='\0')
    {
   	// обработка пробелов
    while (str[i]==' ') i++;
   	//обработка слова
    while (str[i]!=' ' || str[i]!='\0')
    {
   	// что-то делаем
    i++;
    }
    }

    */
   	// начальное присвоение пустой строки нужно для корректности обработки пустой исходной строки
    strcpy(w, "");
   	// указатель - замена индекса, акцент не на букву, а на строку - указатель как начало строки
    char *p = str;
    char word[20];
    int max = 0;
   	// общая схема обработки строк
   	// цикл просмотра групп "пробелы -слово"
   	// цикл продолжается пока длина необработанной части строки больше 0
    while (strlen(p) > 0)	// эквивалентное условие - *p!='\0'
    {
       	// цикл пропуска пробелов
        while (*p == ' ') p++;
       	// проверка на то, что в конце строки были лишние пробелы - слова в этом случае нет
        if (strlen(p) == 0) break;
       	// считывание первого слова в необработанной части строки
        sscanf(p, "%s", word);
       	// обработка слова
        int len = strlen(word);
        if (len > max)
        {
            max = len;
           	// копируем найденное слово в w
            strcpy(w, word);
        }

       	// изменение p - пропускаем обработанное слово - p меняется на длину обработанного слова
        p += len;
    }
}

int GetCountWord(char *str, char *w)
{
   	// указатель - замена индекса, акцент не на букву, а на строку - указатель как начало строки
    char *p = str;
    char word[20];
    int k = 0;	// количество найденных вхождений заданного слова
   	// общая схема обработки строк
   	// цикл просмотра групп "пробелы -слово"
   	// цикл продолжается пока длина необработанной части строки больше 0
    while (strlen(p) > 0)	// эквивалентное условие - *p!='\0'
    {
       	// цикл пропуска пробелов
        while (*p == ' ') p++;
       	// проверка на то, что в конце строки были лишние пробелы - слова в этом случае нет
        if (strlen(p) == 0) break;
       	// считывание первого слова в необработанной части строки
        sscanf(p, "%s", word);
        int len = strlen(word);
        // обработка слова
       	// сравнение текущего слова word с заданным словом w
        if (strcmp(w, word) == 0)
            k++;	// =0 означает, что различий в строках не найдено
        p += len;
    }

    return k;
}
```

## [~] Алгоритмы работы с матрицами
